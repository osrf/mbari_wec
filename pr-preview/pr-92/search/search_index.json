{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Background","text":"<p>The Monterey Bay Aquarium Research Institute (MBARI) Wave-Energy Converter is a point-absorber type wave-energy converter that has been operating in Monterey Bay, CA since 2014. This system was developed as part of MBARI's goals of advancing and demonstrating an autonomous and persistent presence of oceanographic instrumentation in the worlds oceans. This project is complemented by developments in autonomous underwater vehicles, underwater vehicle docking, oceanographic instrumentation, autonomy, and science use. </p> <p></p> <p>The MBARI-WEC is currently maintained by MBARI and operates for six-month periods near the MBARI facility in Moss Landing, California, and averages about 250 Watts of power capture, averaged through the weather cycles and seasons.</p> <p>The MBARI-WEC is a complete system with a four-quadrant electro-hydraulic power-take-off device, board battery storage, control-computers, sensors and instrumentation, and an always-on cell-modem connection to the internet. The architecture of the system is such that critical functions are performed by micro-controllers throughout the system that implement default behaviors and stream sensor data continuously. A Linux computer on the buoy performs data-logging and provides a command interface to the underlying micro-controllers. The system is designed such that the Linux computer is not necessary for safe behavior, if this computer re-boots or goes offline, the system will default to safe behaviors. Additionally, the micro-controllers will ignore damaging commands from the Linux computer. This architecture allows control algorithms running on the Linux computer to be started, stopped, and changed while the device is at sea through the cell-modem connection.  </p> <p>This project provides a software interface to the system to allow such algorithms to be efficiently developed, tested, and executed. Using this interface, MBARI intends to make the system available to external researchers. By providing access to the hardware during the ongoing MBARI deployments of this system, the intention is to provide access to hardware that is often otherwise unavailable. To facilitate this, the project has developed a simulator that provides the same interface as the real hardware, allowing projects the ability to develop and test their work independently, before deployment on the real system which will occur under MBARI supervision.</p> <p>The following sections of this documentation outlines the physical system, describes the software- interfaces available, describes the simulation environment, and provides all information needed to interact with this project. The software interface is built upon the ROS 2 framework, and the simulation environment uses Gazebo Simulator. In addition to descriptions of these systems, the documentation provides a number of tutorials intended to lead a new user through the installation of the necessary tools, basic operation of the system, and provide guidance on implement new algorithms to run on the simulator and ultimately the buoy. This is an open-source project with all necessary code and resources freely available.  </p>"},{"location":"ControlAndTelemetry/","title":"Buoy Control and Telemetry","text":""},{"location":"architecture/","title":"Architecture","text":"<p>The MBARI Wave-Energy-Converter is a small point absorber design that includes a surface expression, an electro-hydraulic PTO, and a submerged heave-cone device.  The system is moored to the seafloor (typically in 80m of water) through a chain-catenary mooring connected to an anchor.  As waves excite the system, a differential motion results between the buoy at the surface and the submerged heave cone.  Resisting this motion results in energy being absorbed by the system, and this energy is converted to electrical form and stored in a battery bank on the buoy. The rest of this section provides details about the various components of the system</p> <p></p>"},{"location":"architecture/#buoy-heave-cone-and-mooring","title":"Buoy, Heave Cone, and Mooring","text":"<p>The buoy in the MBARI-WEC has a diameter of 2.6m, a water-plane area of 5 m^2, and a mass of 1400kg.  This buoy houses the system battery and compute infrastructure, described below.</p> <p>The heave-cone component sits at about 30m depth and provides inertia and drag for the surface-buoy to pull against.  The heave-cone has operable doors that can be opened to reduce the drag and inertial of this component in high sea-states.  When the doors are open, the heave-cone has added-mass of about 10,000kg, in addition to it's own 600kg mass.  When opened, the added-mass reduces to about 3,000kg, which reduces the inertial forcing and increases the natural frequency of the buoy -- heave-cone pair.</p> <p>A chain-catenary mooring and anchor connects to heave-cone to the ocean floor, keeping the buoy on-station.  The system loading due to the mooring increases in higher winds and currents, but remains relatively low compared with the inertia forces the heave-cone creates.</p>"},{"location":"architecture/#pto-system","title":"PTO System","text":"<p>The power take-off device is located below the buoy and converts the differential motion and forces between the buoy and heave-cone from mechanical to electrical energy.  This device is an electro-hydraulic device in which a piston pumps oil through a hydraulic motor, causing an electrical motor/generator to spin and generate electrical energy.  In parallel to the hydraulic ram, a pneumatic piston charged with an inert gas provides a sprint returning force for the system. </p> <p>The combination of the hydraulic and pneumatic pistons creates a spring-damper system for which the spring constant is set by the amount of gas in the system, and the damping behavior is adjustable electronically by varying the torque on the hydraulic motor in response to conditions.  The electrical-drive is a four-quadrant device in which the electric motor can operate as a generator in which energy flows into the battery, or as a motor in which energy is drawn from the battery.  The winding-currents (and resulting torque) can be set arbitrarily, but by default the power take-off device acts as a generator, i.e. a damper resisting motion.</p>"},{"location":"architecture/#electrical-system","title":"Electrical System","text":"<p>The electrical system of this buoy consists of a 325V battery system for energy storage, and a 24V system for powering ancillary instrumentation.  The 325V battery is connected directly to the power take-off device motor drive electronics.  In normal use, the motor-drive device is generating electrical energy at 325V which charges the battery system.  In the case the battery is full (or dis-connected), the motor-drive system directs excess energy to an electrical load-dump device.  This submerged heater plays a critical role in maintaining a load on the power take-off device at all times.  </p> <p>The electrical system also includes 300V-24V power supplies that provides 24 volts to the compute and instrumentation infrastructure in the system.  In the case of low battery voltage due to an extended period of calm seas, the </p>"},{"location":"architecture/#compute-and-control-systems","title":"Compute and Control Systems","text":"<p>The compute and control architecture of the system is such that critical functions are performed by micro-controllers throughout the system that implement default behaviors and stream sensor data continuously.  A Linux computer on the buoy performs data-logging and provides a command interface to the underlying micro-controllers. See figure. The system is designed such that the Linux computer is not necessary for safe behavior, if this computer re-boots or goes offline, the system will default to safe behaviors.  Additionally, the micro-controllers will ignore damaging commands from the Linux computer.  This architecture allows control algorithms running on the Linux computer to be started, stopped, and changed while the device is at sea through the cell-modem connection.  </p> <p></p> <p>The fundamental system behaviors are performed by a network of micro-controller based compute nodes, that communicate with the buoy Linux computer and with one-another through a Controller Area Network (CAN) bus.  There are four of these controllers as follows:</p> <ul> <li> <p>Battery Controller (BC_):  This micro-controller monitors battery voltage, currents, state-of-charge, cell-balance, and environmental conditions inside the battery enclosure.  This controller is largely a data-telemetry gathering item, but also includes an important low-voltage disconnect features which shuts down the 24V battery bus during periods of low-battery state-of-charge.  During these periods the system continues to convert wave-energy and charge the batteries, but all sources of significant battery drain are disconnected which allows the battery to re-charge to a serviceable level, even in calm conditions.</p> </li> <li> <p>Spring Controller (SC_): This micro-controller primarily monitors the piston position and a load-cell located between the buoy and power take-off component.  Additionally, this controller responds to commands to change the gas pressure in each chamber of the pneumatic spring, a pump to move gas from the lower pressure chamber to the higher pressure chamber, and a valve to do the opposite.  Additionally, this controller can turn power on and off to the heave-cone.</p> </li> <li> <p>Power Converter (PC_):  This controller implements the field-oriented control of the winding current in the generator.  It's core function is to control the winding current to a set target, but it performs a number of other specialized functions as well.  In particular, the converter monitors and reports motor RPM, and by default sets the motor winding current target as a pre-defined function of RPM.  This default behavior can be modified (scale and offset), or over-ridden entirely.  In this later case the power converter only over-rides the default winding-current for a short period of time (2 seconds). If a new winding-current command does not arrive in that time, the system reverts to the built-in default behavior.  The power converter also can switch power on and off to the batteries, divert power to an internal load-dump if the batteries are full or disconnected, and monitors the bus voltage and other health functions.  The power converter also obeys current draw/charge limits specified depending on the size and capability of the attached battery pack.</p> </li> <li> <p>Heave-cone Controller (TC_):  This controller is responsible for opening and closing the heave-cone doors when commanded.  For storm-safety, the controller will open the doors one hour after power from the surface is lost, or a watchdog timer expires.  Battery back-up of the system enables this, and the buoy system must issue a watchdog reset at least every hour to keep the doors closed.  In addition, this controller has an IMU and pressure sensor that provides attitude and depth information about the heave-cone.  Note:  This is denoted \"TC_\", the T stands for trefoil, which is French for clover and refers to the heave-cone doors themselves.</p> </li> </ul> <p>The on-board linux computer is accessible from shore over a radio link (cell-modem, satellite, or line-of-site radio).  This link enables  enabling data-telemetry, real-time control, and software-updates to be applied to the Linux computer.</p>"},{"location":"architecture/#sensors-and-measurements","title":"Sensors and Measurements","text":"<p>** Load Cell: ** This is a load cell between the buoy and the power take-off device, and has a range of up to 20,000lbs.</p> <p>** Piston Position: ** Inside the pneumatic spring there is a laser range-finder that continuously monitors the position of the power take-off piston.  </p> <p>** Pneumatic Pressures: **  The spring controller monitors the pressures of the two gas-chambers that make up the pneumatic spring.</p> <p>** Hydraulic Compensator Pressure **  The hydraulic system has a small pressurized accumulator attached to the low-pressure side of the hydraulic circuit. This applies a small pressure (3psi) to ensure seawater does not enter the hydraulic system.  An abrupt drop in this pressure indicates a hydraulic leak and is therefore monitored and reported.</p> <p>** Buoy Inertial Measurement Unit: ** On-board the buoy there is a GPS disciplined six DOF attitude-heading and reference system.  This unit monitors and reports the buoys attitude and GPS location.</p> <p>** Heave Cone Inertial Measurement Unit: **  On-board the heave-cone there is an attitude-heading and reference system with a magnetometer and pressure sensor that reports the heave-cones orientation and depth.</p> <p>** Electrical System Sensors: **  Voltages and currents are monitored throughout the electrical system and reported by various controllers.  In particular the motor winding currents, the load-dump current, and the battery current are all independently monitored and reported.</p>"},{"location":"atseaoperation/","title":"At Sea Operation","text":"<p>Under Construction</p>"},{"location":"citation/","title":"Citation","text":"<p>If you use this software, please cite it as below:</p> <ul> <li>APA</li> </ul> <pre><code>Hamilton, A., Anderson, M., Poubel, L., Dutia, D., Carroll, M., Zhang, M., McEwen, R., &amp; Mayans, J. (2023). MBARI Wave Energy Conversion Simulation (Version 1.0.0) [Computer software]. https://github.com/osrf/mbari_wec\n</code></pre> <ul> <li>BibTeX</li> </ul> <pre><code>@software{Hamilton_MBARI_Wave_Energy_2023,\n author = {Hamilton, Andrew and Anderson, Michael and Poubel, Louise and Dutia, Dharini and Carroll, Michael and Zhang, Mabel and McEwen, Rob and Mayans, Joan},\n month = may,\n title = {{MBARI Wave Energy Conversion Simulation}},\n url = {https://github.com/osrf/mbari_wec},\n version = {1.0.0},\n year = {2023}\n}\n</code></pre>"},{"location":"license/","title":"License","text":"<p>Copyright 2022 Open Source Robotics Foundation, Inc. and Monterey Bay Aquarium Research Institute</p> <p>Licensed under the Apache License, Version 2.0</p>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#forum","title":"Forum","text":"<p>This project maintains a discussion forum and we try to respond as quickly as possible to all questions and discussion. This is the best way to reach the developers and maintainers of this project</p>"},{"location":"resources/#source-code","title":"Source Code","text":"<p>The simulator used in this project utilizes the Gazebo simulator as the base, with a number of custom PlugIns developed by this project to implement specific features needed to simulate this WEC. Gazebo and this projects plugins are open source projects and the source code for these can be accessed at gz-sim and mbari_wec.  Documentation in these respositories is intended for developers but does provide some detailed information about how the simulation works.</p>"},{"location":"resources/#publications","title":"Publications","text":"<pre><code>Dizon, Chris, Ryan Coe, Andrew Hamilton, Dominic Forbush, Michael Anderson, Ted Brekken, and Giorgio\nBacelli. 2024. \"Analysis on Evaluations of Monterey Bay Aquarium Research Institute\u2019s Wave Energy\nConverter\u2019s Field Data Using WEC-Sim and Gazebo: A Simulation Tool Comparison\" Applied Sciences 14,\nno. 23: 11169. https://doi.org/10.3390/app142311169\n</code></pre>"},{"location":"resources/#references","title":"References","text":""},{"location":"roadmap/","title":"Project Roadmap","text":"<p>Under Construction</p>"},{"location":"ros2/","title":"ROS 2 Interface","text":"<p>Under Construction</p>"},{"location":"simulation/","title":"Simulation","text":"<p>A computer simulation environment has been created that simulates the dynamics of the wave-energy converter and emulates the ROS 2 messages used on the buoy system.  This simulation includes a solver of the multi-body dynamics of the system, a numerical representation of the behavior and losses of the electro-hydraulic PTO, and a numerical simulation of the wave-buoy interaction processes based on linear hydrodynamic theory.</p> <p>The aim of this simulation is to provide a computer based simulation that replicates the physical systems behavior and also interacts with computer code in the same way the physical buoy system does.  The aim is that code running on a desktop Linux machine can run unchanged on the physical buoy, and that the response of the simulated buoy is indistinguishable from the real system.  The following sections provide some details of this simulator, and additional specifics are in the  theory  section.</p>"},{"location":"simulation/#gazebo","title":"Gazebo","text":"<p>The simulation environment here is built upon the popular Gazebo Simulator that is supported by the Open Source Robotics Foundation.  The core of this simulator is provided by a physics engine that is responsible for solving the 6 degree-of-freedom multi-body equations of motion.  This engine determines the position in space solution of all the bodies in a simulation, subject to the forces that are acting on those bodies in any particular environment.  This multi-body simulator also can enforce constraints on, and joints between, the bodies, allowing one to develop simulations in which two bodies are only allowed to slide by one another in one degree of freedom, for instance.  Gazebo includes a number of forcings that are typical in robotics, gravity, contact forces between bodies, hydrodynamic drag forces, etc.  Also, when used with the DART physics engine, Gazebo can include a general added-mass matrix which adds inertial forcing on specified bodies due to the tendency of the fluid surrounding a body to be accelerated along with the body.  This is a critically important feature in underwater robotics and simulation efforts.  Of course, all the required forcings to</p> <p>In particular, this project has created plugins that provide forcing on the components of wave-energy converter system that are specific to this device and application.  These plugins are loaded at run-time so exist independently of the main Gazebo software, but behave in an integrated way during simulations.  The plug-in code described in the following sections implement specific forcings needed by this project.</p>"},{"location":"simulation/#electro-hydraulic-pto","title":"Electro-Hydraulic PTO","text":"<p>As described in the Architecture section, the MBARI wave-energy converter implements a custom developed electro-hydraulic power take-off device that converts mechanical power of a moving piston rod (force times velocity) to/from electrical energy that is supplied to or drawn from a battery system (voltage times current).  This device consists of a linear hydraulic ram that is connected to a rotary hydraulic motor, linear motion of the ram translates to rotary motion of a shaft, and vice versa.  The hydraulic motor shaft is directly coupled to a permanent magnet servo motor/driver.  The power electronics maintains a commanded torque on the motor which results from current flowing to/from the battery system as appropriate.  The Gazebo plugin developed to simulate this device takes in the piston velocity and commanded torque, and computes the resulting hydraulic pressure, motor RPM, and battery voltage and current.  The plugin is programmed with the same default motor-current/RPM relationship as the physical system, and also respects the same limits on motor and battery current, motor RPMs, etc.  A key simplifying assumption made in this model is that the rotary inertia of the motor shaft is negligible, and the hydraulic oil is incompressible.  These assumptions cause the model of the PTO to be a quasi-static solution that neglects inertia forces of the rotary components of the motor.  This has been shown to be a reasonable assumption at the motion frequencies the system operates at, and greatly increases the speed at which the solution progresses.  The inertia of the piston itself is included in the simulation as it is an independent body in the equations of motion, constrained to move linearly with respect to the PTO housing.</p>"},{"location":"simulation/#pneumatic-spring","title":"Pneumatic Spring","text":""},{"location":"simulation/#free-surface-hydrodynamics","title":"Free-Surface Hydrodynamics","text":""},{"location":"simulation/#controller-interfaces","title":"Controller Interfaces","text":""},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#modeling-technique-overview","title":"Modeling Technique Overview","text":"<p>The numerical modeling used in this simulator relies upon the Gazebo simulators ability to solve for the  motion of a collection of rigid bodies connected by various types of joints.  Gazebo can use several  different physics solvers to perform this solution, and the wave-energy buoy simulator in this project uses the DART physics engine.  The physics engine solves the multi-body six degree-of-freedom problem for the motion of the connected buoy, power-take-off device, and heave cone, subject to initial conditions and forces that act on the various components as the simulation progresses.  In the Gazebo simulator, these forces are provided by plugin code that applies forces to each body based on the state (position and velocity) of each component in the system at each timestep.  </p> <p>The Gazebo simulator already includes several plugins that provide relevant forces such as buoyancy and hydrodynamic drag.  Additionally, several additional plugins have been created for this simulator that provide the forcings on the system due to the electro-hydraulic power-take-off system, the pneumatic spring system, the tether connecting the PTO to the heave-cone, the mooring system that anchors the system, and the forcing on the buoy from the ocean surface waves.  The sections below outline some details about how each of these forcings are modelled and computed.  First however,  the specific physical characteristics of the MBARI WEC are tabulated for reference.</p>"},{"location":"theory/#physical-characteristics","title":"Physical Characteristics","text":"<p>Each rigid body in the simulation has a \"Link Frame\" coordinate system in which all other characteristics of the body are defined in for computational purposes.  This link-frame coordinate system is often selected to be at the location of a joint that connects the various bodies (which are also called links in the vernacular of Gazebo). Also, the description below includes alternative notation for added mass, e.g.  , in the style of Newman. </p>"},{"location":"theory/#surface-buoy","title":"Surface Buoy","text":"Description Units Buoy Mass 1400 kg Displacement (undisturbed buoy) 2.39 m Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, 2.03) m Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, 2.05) m Center of Waterplane in Link Frame, including PTO and cone (0.0, 0.0, 2.27) m Second moment of area of water plane, about roll axis 1.37 m Second moment of area of water plane, about pitch axis 1.37 m Roll Moment of Inertia (MOI) about center of mass 1450 kg m Pitch Moment of Inertia about center of mass 1450 kg m Yaw Moment of Inertia about center of mass 670 kg m Waterplane Area (undisturbed buoy) 5.47 m Surge Added Mass () 260 kg Surge-Pitch Added Mass, origin at c.m. () 150 kg Sway Added Mass ( ) 260 kg Sway-Roll Added Mass, origin at c.m. () -150 kg Heave Added Mass () 3080 kg Roll Added Mass MOI, origin at c.m. () 330 kg m Pitch Added Mass MOI, origin at c.m. () 330 kg m Surge Quadratic Drag -430 kg/m Sway Quadratic Drag -430 kg/m Heave Quadratic Drag -3280 kg/m Roll Quadratic Drag: -880 kg m Pitch Quadratic Drag: -880 kg m Yaw Quadratic Drag: -50 kg m <ul> <li>Buoy Link Frame is located at base of the buoy bridle at the pivot.</li> <li>Unspecified stability derivative values (, , , etc) are zero. </li> <li>Stability derivatives are specified about the link frame origin, i.e. the pivot.</li> <li>Mass-moments of inertia and added-mass-moments of inertia are specified about the center of mass.</li> <li>Added-mass values are infinite frequency.</li> <li>Free-Surface Hydrodynamic Coefficients and Impulse Response Functions can be found here:</li> </ul>"},{"location":"theory/#power-take-off-device","title":"Power Take-Off Device","text":"Description Units PTO Mass 605 kg PTO Displacement .205 m Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -4.0) m Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, -3.0) m Roll Moment of Inertia about center of mass 3525 kg m Pitch Moment of Inertia about center of mass 3525 kg m Yaw Moment of Inertia about center of mass 10 kg m Surge Added Mass () 310 kg Sway Added Mass () 310 kg Heave Added Mass () 10 kg Roll Added Mass MOI  () 2030 kg m Pitch Added Mass MOI () 2030 kg m Surge Quadratic Drag -1140 kg/m Sway Quadratic Drag -1140 kg/m Heave Quadratic Drag -50 kg/m Roll Quadratic Drag -195400 kg m Pitch Quadratic Drag -195400 kg m Yaw Quadratic Drag -50 kg m <ul> <li>PTO Link Frame is located at top attachment of the PTO (where connects to the buoy).</li> <li>Unspecified stability derivative values (, , , etc) are zero. </li> <li>Stability derivatives are specified about the link frame origin, i.e. the pivot.</li> <li>Mass-moments of inertia and added-mass-moments of inertia are specified about the center of mass.</li> </ul>"},{"location":"theory/#piston","title":"Piston","text":"Description Units Piston Mass 48.0 kg Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -2.58) m Roll Moment of Inertia 100.0 kg m Pitch Moment of Inertia 100.0 kg m Yaw Moment of Inertia 5.0 kg m <ul> <li>The piston is contained with the PTO housing, so it has mass and moments of inertial, but contributes  no buoyancy, added mass, or quadratic fluid drag.</li> </ul>"},{"location":"theory/#heave-cone","title":"Heave Cone","text":"Description Units Heave Cone Mass 820 kg Heave Cone Displacement .12 m Center of Gravity in Link Frame (x,y,z) (0.0, 0.0, -1.25) m Center of Buoyancy in Link Frame (x,y,z) (0.0, 0.0, -1.21) m Roll Moment of Inertia about the center of mass 340 kg m Pitch Moment of Inertia about the center of mass 340 kg m Yaw Moment of Inertia about the center of mass 610 kg m Surge Added Mass () 720 kg Sway Added Mass () 720 kg Sway-Roll Added Mass MOI () -900 kg m Heave Added Mass: Doors Closed () 9330 kg Heave Added Mass: Doors Open 3000 kg Roll Added Mass MOI () 2870 kg m Pitch Added Mass MOI() 2870 kg m Yaw Added Mass MOI () 10 kg m Surge Quadratic Drag -1580 kg/m Sway Quadratic Drag -1580 kg/m Vertical Quadratic Drag: Doors Open -3200 kg/m Vertical Quadratic Drag: Doors Closed -3900 kg/m Roll Quadratic Drag: -4620 kg m Pitch Quadratic Drag: -4620 kg m Yaw Quadratic Drag: -50 kg m <ul> <li>Heave-Cone Link Frame is located at top attachment of the Heave Cone (where it connects to the tether).</li> <li>Unspecified stability derivative values (, , , etc) are zero. </li> <li>Stability derivatives are specified about the link frame origin, i.e. the pivot.</li> <li>Mass-moments of inertia and added-mass-moments of inertia are specified about the center of mass.</li> </ul>"},{"location":"theory/#electro-hydraulic-pto-forces","title":"Electro-Hydraulic PTO Forces","text":""},{"location":"theory/#pneumatic-spring-forces","title":"Pneumatic Spring Forces","text":""},{"location":"theory/#definitions","title":"Definitions","text":"Description Units Piston position m Piston velocity m/s Mass of gas in chamber kg Temperature of gas K Gas pressure Pa Chamber volume (dependent on piston position) m Specific Gas Constant N J/kg/K Chamber dead volume (fully compressed) m Specific Heat Capacity N (constant pressure) J/kg/K Surface area of piston head m Polytropic index (Adiabatic if  for N) N/A Coefficient of heat transfer (Newton's Law of Cooling) 1/s"},{"location":"theory/#model","title":"Model","text":"<p>Under compression and expansion, the pressure, volume and temperature of the Nitrogen in each chamber evolves according to Ideal Gas Law:</p> <p> </p> <p>and a polytropic process:</p> <p> </p> <p>with hysteresis, there are two values for the polytropic index,  and , to capture behavior when the gas is compressing or expanding. Using this quasi-static solution and discrete time steps, and also incorporating hysteresis, the process becomes:</p> <p> </p> <p>where  is the current time step.</p> <p>Whenever the piston velocity is slow enough, the process is dominated by heat loss and modeled with Newton's Law of Cooling (using forward difference) followed by an update of pressure using Ideal Gas Law:</p> <p> </p> <p>The mass of the Nitrogen in each chamber is determined from inputs in the SDF:</p> <p> </p> <p>and is used for mass flow between chambers in simulating the pump/valve.</p>"},{"location":"theory/#determining-parameter-values","title":"Determining Parameter Values","text":"<p>Linear regression was used to determine the polytropic indices for each chamber using empirical data from the physical system. Using pressure vs volume curves,  is determined from increasing volume, and  is determined from decreasing volume. The data is then preconditioned by taking the logarithm to linearize and perform regression to find the parameters. For a polytropic process:</p> <p> </p> <p>so,</p> <p> </p> <p>in block matrix notation where  and  are the arrays of volume and pressure data, respectively. The other parameters in the system are taken from CAD or empirically determined by comparing logged data from prescribed motion between simulation and the physical test bench.</p>"},{"location":"theory/#tether-forces","title":"Tether Forces","text":""},{"location":"theory/#mooring-forces","title":"Mooring Forces","text":""},{"location":"theory/#ocean-wave-forces","title":"Ocean Wave Forces","text":""},{"location":"tutorials/","title":"Tutorials","text":""},{"location":"tutorials/#installation","title":"Installation","text":"<ul> <li>Install from source</li> <li>Install using Docker </li> </ul>"},{"location":"tutorials/#running-the-simulator","title":"Running the Simulator","text":"<ul> <li>Run the Simulator</li> <li>View ROS 2 Messages </li> <li>View ROS 2 Messages with Plotjuggler</li> <li>Simulator Output Data Logs</li> <li>Control Simulator with pbcmd</li> <li>Adjust Simulator parameters</li> </ul>"},{"location":"tutorials/#adding-control-code","title":"Adding Control Code","text":"<ul> <li>ROS 2 Messages and Services</li> <li>Controller GitHub Template (Python)</li> <li>Controller GitHub Template (C++)</li> <li>Linear Damper Example (Python)</li> <li>Linear Damper Example (C++)</li> <li>Open-Loop Force Command Example (C++)</li> <li>Open-Loop Force Command Example (Python)</li> </ul>"},{"location":"ROS2/cpp_api/","title":"class Interface","text":"<p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#161</p> <p>brief ROS 2 Interface node for commanding and subscribing to buoy controllers and sensors.</p> <p>This template class uses the Curiously Recurring Template Pattern (CRTP) to provide a compile-time  polymorphic interface for creating node-based controllers. By using CRTP, derived classes can  override callback methods and parameter-setting behavior without incurring the overhead of virtual  dispatch. The derived class must pass itself as the template parameter to <code>Interface</code>, enabling the  base class to call into user-defined implementations.</p> <p>Provides service clients and functions to send commands to and receive telemetry from the MBARI WEC  controllers:</p> <ul> <li>AHRS</li> <li>Power</li> <li>Spring</li> <li>Battery</li> <li>Trefoil</li> </ul> <p>If the user has overridden one of these callbacks in their derived class, the corresponding topic  subscriber will be set up and routed to their implementation. If not, that topic will not be  subscribed to. The relevant callbacks include:</p> <ul> <li>ahrs_callback</li> <li>battery_callback</li> <li>spring_callback</li> <li>power_callback</li> <li>trefoil_callback</li> <li>powerbuoy_callback</li> </ul> <p>Template argument: ControllerImplCRTP The concrete controller class that inherits from this interface. It must implement any callbacks or parameter-setting routines it needs.</p> <p>How to Use:</p> <ol> <li> <p>Include the header for <code>Interface</code>:</p> <pre><code>#include &lt;buoy_api/interface.hpp&gt;\n</code></pre> </li> <li> <p>Forward-declare any policies or helper classes you will use:</p> <pre><code>struct PBTorqueControlPolicy;  // defined by user in torque_control_policy.hpp\n</code></pre> </li> <li> <p>Define your controller class by inheriting from <code>buoy_api::Interface&lt;YourClass&gt;</code>     making sure to add <code>friend CRTP</code>:</p> <pre><code>class PBTorqueController final : public buoy_api::Interface&lt;PBTorqueController&gt;\n\n{\n\npublic:\n\n  explicit PBTorqueController(const std::string &amp; node_name);\n\n  ~PBTorqueController() = default;\n\n\n\nprivate:\n\n  friend CRTP;  // Enables base to access overrides.\n\n  void set_params() final;\n\n  void power_callback(const buoy_interfaces::msg::PCRecord &amp; data);\n\n  std::unique_ptr&lt;PBTorqueControlPolicy&gt; policy_;\n\n};\n</code></pre> </li> <li> <p>Implement <code>set_params()</code> to declare or update ROS2 parameters to update your policy class.</p> </li> <li> <p>Override any telemetry callbacks to process incoming data.</p> </li> <li> <p>Construct your controller in your <code>main()</code> function, passing in the desired node name.    The base <code>Interface</code> handles common setup: parameters, services, publishers, and subscribers.</p> </li> </ol> <p>Benefits of CRTP in This Context:</p> <ul> <li>Zero-cost abstraction: No virtual table; callbacks are resolved at compile time.</li> <li>Flexible overrides: Only override what you use.</li> <li>Simplified boilerplate: Base class manages ROS2 setup.</li> </ul> <p>Inherits from ROS 2 Node</p>"},{"location":"ROS2/cpp_api/#functions","title":"Functions","text":""},{"location":"ROS2/cpp_api/#interfacecontrollerimplcrtp","title":"Interface&lt;ControllerImplCRTP&gt;","text":"<pre><code>public void Interface&lt;ControllerImplCRTP&gt;(const std::string &amp; node_name)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#166</p>"},{"location":"ROS2/cpp_api/#interfacecontrollerimplcrtp_1","title":"Interface&lt;ControllerImplCRTP&gt;","text":"<pre><code>public void Interface&lt;ControllerImplCRTP&gt;(const std::string &amp; node_name, const bool wait_for_services, const bool check_for_services)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#178</p> <p>brief Initialize the Interface node.</p> <p>node_name Name of the ROS2 node. wait_for_services If true and check_for_services, block until services are available. check_for_services If true, attempt to verify service availability before use.  </p>"},{"location":"ROS2/cpp_api/#use_sim_time","title":"use_sim_time","text":"<pre><code>public void use_sim_time(bool enable)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#409</p> <p>brief Enable/Disable using sim time in Node clock from /clock.</p> <p>enable True to use /clock, False to use system time.</p>"},{"location":"ROS2/cpp_api/#set_pc_pack_rate","title":"set_pc_pack_rate","text":"<pre><code>public void set_pc_pack_rate(const uint8_t &amp; rate_hz)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#422</p> <p>brief Set publish rate of PC Microcontroller telemetry.</p> <p>rate_hz Desired publish rate in Hz.</p>"},{"location":"ROS2/cpp_api/#set_sc_pack_rate","title":"set_sc_pack_rate","text":"<pre><code>public void set_sc_pack_rate(const uint8_t &amp; rate_hz)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#439</p> <p>brief Set publish rate of SC Microcontroller telemetry.</p> <p>rate_hz Desired publish rate in Hz.</p>"},{"location":"ROS2/cpp_api/#set_pc_pack_rate_param","title":"set_pc_pack_rate_param","text":"<pre><code>public void set_pc_pack_rate_param(const double &amp; rate_hz)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#456</p> <p>brief Set publish rate of PC Microcontroller telemetry via parameter server.</p> <p>rate_hz Desired publish rate in Hz.</p>"},{"location":"ROS2/cpp_api/#set_sc_pack_rate_param","title":"set_sc_pack_rate_param","text":"<pre><code>public void set_sc_pack_rate_param(const double &amp; rate_hz)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#477</p> <p>brief Set publish rate of SC Microcontroller telemetry via parameter server.</p> <p>rate_hz Desired publish rate in Hz.</p>"},{"location":"ROS2/cpp_api/#send_valve_command","title":"send_valve_command","text":"<pre><code>public shared_future send_valve_command(const uint16_t &amp; duration_sec)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#553</p> <p>brief Turn valve on for a duration to lower mean piston position.</p> <p>duration_sec Valve on duration in seconds.</p> <p>return A future containing the service response.</p>"},{"location":"ROS2/cpp_api/#send_pump_command","title":"send_pump_command","text":"<pre><code>public shared_future send_pump_command(const float &amp; duration_mins)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#570</p> <p>brief Turn pump on for a duration to raise mean piston position.</p> <p>duration_mins Pump on duration in minutes.</p> <p>return A future containing the service response.</p>"},{"location":"ROS2/cpp_api/#send_pc_wind_curr_command","title":"send_pc_wind_curr_command","text":"<pre><code>public shared_future send_pc_wind_curr_command(const float &amp; wind_curr)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#587</p> <p>brief Set winding current setpoint to control piston damping.</p> <p>wind_curr Wind current setpoint in Amps.</p> <p>return A future containing the service response.</p>"},{"location":"ROS2/cpp_api/#send_pc_bias_curr_command","title":"send_pc_bias_curr_command","text":"<pre><code>public shared_future send_pc_bias_curr_command(const float &amp; bias_curr)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#606</p> <p>brief Set bias current setpoint to control piston damping offset. A high bias in either direction will move the piston back and forth.</p> <p>bias_curr Bias current setpoint in Amps.</p> <p>return A future containing the service response.</p>"},{"location":"ROS2/cpp_api/#send_pc_scale_command","title":"send_pc_scale_command","text":"<pre><code>public shared_future send_pc_scale_command(const float &amp; scale)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#623</p> <p>brief Set damping gain.</p> <p>scale Damping gain.</p> <p>return A future containing the service response.</p>"},{"location":"ROS2/cpp_api/#send_pc_retract_command","title":"send_pc_retract_command","text":"<pre><code>public shared_future send_pc_retract_command(const float &amp; retract)\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#640</p> <p>brief Set additional damping gain in the piston retract direction.</p> <p>retract Additional damping gain for retraction.</p> <p>return A future containing the service response.</p>"},{"location":"ROS2/cpp_api/#set_params","title":"set_params","text":"<pre><code>protected void set_params()\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#659</p> <p>brief Set user-defined Node parameters (e.g., custom controller gains).</p>"},{"location":"ROS2/cpp_api/#ahrs_callback","title":"ahrs_callback","text":"<pre><code>protected void ahrs_callback(const buoy_interfaces::msg::XBRecord &amp; )\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#666</p> <p>brief Override this function to subscribe to /ahrs_data to receive XBRecord telemetry.</p> <p>data Incoming XBRecord.</p>"},{"location":"ROS2/cpp_api/#battery_callback","title":"battery_callback","text":"<pre><code>protected void battery_callback(const buoy_interfaces::msg::BCRecord &amp; )\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#673</p> <p>brief Override this function to subscribe to /battery_data to receive BCRecord telemetry.</p> <p>data Incoming BCRecord.</p>"},{"location":"ROS2/cpp_api/#spring_callback","title":"spring_callback","text":"<pre><code>protected void spring_callback(const buoy_interfaces::msg::SCRecord &amp; )\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#680</p> <p>brief Override this function to subscribe to /spring_data to receive SCRecord telemetry.</p> <p>data Incoming SCRecord.</p>"},{"location":"ROS2/cpp_api/#power_callback","title":"power_callback","text":"<pre><code>protected void power_callback(const buoy_interfaces::msg::PCRecord &amp; )\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#687</p> <p>brief Override this function to subscribe to /power_data to receive PCRecord telemetry.</p> <p>data Incoming PCRecord.</p>"},{"location":"ROS2/cpp_api/#trefoil_callback","title":"trefoil_callback","text":"<pre><code>protected void trefoil_callback(const buoy_interfaces::msg::TFRecord &amp; )\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#694</p> <p>brief Override this function to subscribe to /trefoil_data to receive TFRecord telemetry.</p> <p>data Incoming TFRecord.</p>"},{"location":"ROS2/cpp_api/#powerbuoy_callback","title":"powerbuoy_callback","text":"<pre><code>protected void powerbuoy_callback(const buoy_interfaces::msg::PBRecord &amp; )\n</code></pre> <p>Defined at buoy_api_cpp/include/buoy_api/interface.hpp#701</p> <p>brief Override this function to subscribe to /powerbuoy_data to receive PBRecord telemetry.</p> <p>data Incoming PBRecord containing a slice of all microcontroller telemetry data.</p>"},{"location":"ROS2/messages/","title":"Buoy Interfaces (ROS 2 Messages)","text":"<p>Several ROS 2 messages/services have been defined in the buoy_interfaces package to access telemetry and send commands.</p> <p>For more information about ROS 2 interfaces, see docs.ros.org.</p>"},{"location":"ROS2/messages/#messages-msg-and-topics","title":"Messages (.msg) and Topics","text":"<p>Collection of telemetry (feedback) from buoy sensors and microcontrollers.</p>"},{"location":"ROS2/messages/#telemetry","title":"Telemetry","text":"<p>Telemetry data from sensors available per microcontroller</p> <ul> <li> <p>type: <code>BCRecord</code>   topic: <code>/battery_data</code>   Description: Battery Controller Telemetry</p> <pre><code>std_msgs/Header header  # contains time: .stamp\nint16 seq_num           # incremental number of messages sent\nfloat32 voltage         # total battery voltage in Volts\nfloat32 ips             # current in Amps\nfloat32 vbalance        # cell balancing voltage\nfloat32 vstopcharge     # voltage threshold at which charging should stop\nfloat32 gfault          # ground fault level\nfloat32 hydrogen        # hydrogen gas level\nuint16 status           # microcontroller status bitfield\n</code></pre> </li> <li> <p>type: <code>PCRecord</code>   topic: <code>/power_data</code>   Description: Power Controller Telemetry</p> <pre><code>std_msgs/Header header     # contains time: .stamp\nint16 seq_num              # incremental number of messages sent\nfloat32 rpm                # motor speed\nfloat32 sd_rpm             # stddev rpm\nfloat32 voltage            # motor voltage\nfloat32 draw_curr_limit    # output current limit\nfloat32 bcurrent           # battery current\nfloat32 wcurrent           # torque controller winding current\nfloat32 torque             # motor torque (Nm)\nfloat32 diff_press         # hydraulics differential pressure\nfloat32 bias_current       # torque controller bias current (on windings)\nfloat32 loaddc             # load dump current\nfloat32 scale              # torque controller gain\nfloat32 retract            # additional torque controller gain applied in retraction\nfloat32 target_v           # target voltage\nfloat32 target_a           # target current\nfloat32 charge_curr_limit  # input charge current limit\n\n# Note: Not Currently Implemented in Sim Controller\nuint16 MODE=1                     # controller mode. specified by defines in config.h (GENERATOR_MODE, TORQUE_MODE)\nuint16 TORQUE_CMD_LIMITED=4       # defines what is limited the Torque Command\n                                  # (0 = Not limited, 1 = Rate, 2 = Min, 3 = Max).\nuint16 BATT_SWITCH_REQUEST=8      # Indicates state of battery switch that the user desires.\n                                  # 0 = off, 1 = on\nuint16 BATT_SWITCH_SETTING=16     # Indicates instantaneous setting of Battery Switch\nuint16 SLOW_SWITCH_SETTING=32     # Indicates instantaneous setting of Bettery Slow Switch\nuint16 EXT_VOLTAGE_DETECT=64      # Indicates if &gt;170V is available on outside connector\nuint16 GAIN_SCHEDULE_MODE=128     # 0 = off. 1 = on.\nuint16 OVER_CURRENT_SHUTDOWN=256  # 1 indicates drive is in overcurrent shutdown.\nuint16 OVER_VOLTAGE_SHUTDOWN=512  # 1 indicates drive is in overvoltage shutdown.\nuint16 SPRING_RANGE_VALID=1024    # 1 indicates the current SC_Range value is valid (received within\n                                  # approximately SC_RANGE_VALID_TIMEOUT milliseconds)\nuint16 PERMISSIVE_MODE=2048       # 1 indicates user has selected \"permissive mode\" which allows\n                                  # WindingCurrent commands to be set even if SpringController Range\n                                  # packets aren't arriving\nuint16 status                     # status bitfield\n</code></pre> </li> <li> <p>type: <code>SCRecord</code>   topic: <code>/spring_data</code>   Description: Spring Controller Telemetry</p> <pre><code>std_msgs/Header header  # contains time: .stamp\nint16 seq_num           # incremental number of messages sent\nint16 load_cell         # load cell reading (N)\nfloat32 range_finder    # piston position (in meters from full retraction)\nfloat32 upper_psi       # upper (top half of air spring) Nitrogen chamber pressure (PSI)\nfloat32 lower_psi       # lower (bottom half of air spring) Nitrogen chamber pressure (PSI)\nint64 epoch             # Timestamp in UNIX epoch time (seconds)\nfloat32 salinity        # (unused) salinity measurement\nfloat32 temperature     # (unused) temperature measurement\n\n# Status and control bitfields  \nuint16 RELIEF_VALVE_REQUEST=1     # Request to open/close valve\nuint16 RELIEF_VALVE_STATUS=128    # Status of Relief valve open/close\nuint16 PUMP_REQUEST=256           # Request to turn pump on or off\nuint16 PUMP_STATUS=512            # Status of pump switch\nuint16 PUMP_OVER_TEMP=1024        # Status of pump OverTemp signal\nuint16 PUMP_TOGGLE=2048           # Status of pump Toggle.\nuint16 TETHER_POWER_REQUEST=4096  # Request to turn tether power on or off\nuint16 TETHER_POWER_STATUS=8192   # Status of tether power relay\nuint16 LR_FAULT=16384             # Status of LRF fault input\nuint16 AUX_FAULT=32768            # Status of AUX fault input\nuint16 status                     # status bitfield\n</code></pre> </li> <li> <p>type: <code>TFRecord</code>   topic: <code>/trefoil_data</code>   Description: Trefoil Controller Telemetry</p> <pre><code>std_msgs/Header header         # contains time: .stamp\nint32 seq_num                  # incremental number of messages sent\nint32 power_timeouts           \nfloat32 tether_voltage         \nfloat32 battery_voltage        \nfloat32 pressure               \n\n# IMU containing orientation, angular velocity and linear acceleration\nsensor_msgs/Imu imu            \n\n# Magnetic field in Tesla\nsensor_msgs/MagneticField mag\n\nint16 status                   # status bitfield: contains trefoil door state\nint16 vpe_status               \n\nint32 comms_timeouts           \nint32 motor_status             \nint32 motor_current            \nint32 encoder                  \n</code></pre> </li> <li> <p>type: <code>XBRecord</code>   topic: <code>/ahrs_data</code>   Description: Crossbow AHRS Telemetry</p> <pre><code>std_msgs/Header header  # contains time: .stamp\n\n# IMU data:\n# - orientation: quaternion [x, y, z, w] (radians)\n# - angular_velocity: 3D vector in rad/s\n# - linear_acceleration: 3D vector in m/s\u00b2 (not in g)\nsensor_msgs/Imu imu\n\n# GPS fix:\n# - latitude, longitude in degrees\n# - altitude in meters above the WGS84 ellipsoid\nsensor_msgs/NavSatFix gps\n\n# Velocity in the North-East-Down (NED) frame (m/s)\n# - x = North\n# - y = East\n# - z = Down (positive downwards)\ngeometry_msgs/Vector3 ned_velocity\n\n# Temperature of the X-rate gyro (Celsius)\nsensor_msgs/Temperature x_rate_temp\n</code></pre> </li> </ul>"},{"location":"ROS2/messages/#consolidated-time-synchronized-telemetry","title":"Consolidated (Time-Synchronized) Telemetry","text":"<p>Snapshot in time of all data from the buoy.</p> <ul> <li> <p>type: <code>PBRecord</code>   topic: <code>/powerbuoy_data</code>   Description: All Telemetry in one time-synchronized message</p> <pre><code>PCRecord pc  # Power Controller telemetry\nBCRecord bc  # Battery Controller telemetry\nSCRecord sc  # Spring Controller telemetry\nTFRecord tf  # Trefoil Controller telemetry\nXBRecord xb  # Crossbow AHRS telemetry\n</code></pre> </li> </ul>"},{"location":"ROS2/messages/#services-srv","title":"Services (.srv)","text":"<ul> <li> <p>type: <code>PumpCommand.srv</code>   topic: <code>/pump_command</code>   Description: Turn pump on for a duration in minutes to raise mean piston position.</p> <pre><code>float32 OFF=0\nfloat32 duration_mins  # OFF, 1..10\n</code></pre> </li> <li> <p>type: <code>ValveCommand.srv</code>   topic: <code>/valve_command</code>   Description: Turn valve on for a duration in seconds to lower mean piston position.</p> <pre><code>uint16 OFF=0\nuint16 duration_sec  # OFF, 1..127\n</code></pre> </li> <li> <p>type: <code>TFSetPosCommand.srv</code>   topic: <code>/tf_set_pos_command</code>   Description: Open or close Trefoil doors</p> <pre><code>uint16 OPEN=0\nuint16 CLOSED=1\nuint16 position\n</code></pre> </li> <li> <p>type: <code>PCScaleCommand.srv</code>   topic: <code>/pc_scale_command</code>   Description: Set damping gain</p> <pre><code>float32 scale  # 0.5..1.4\n</code></pre> </li> <li> <p>type: <code>PCRetractCommand.srv</code>   topic: <code>/pc_retract_command</code>   Description: Set additional damping gain in retraction</p> <pre><code>float32 retract  # 0.4..1.0\n</code></pre> </li> <li> <p>type: <code>PCWindCurrCommand.srv</code>   topic: <code>/pc_wind_curr_command</code>   Description: Set winding current setpoint to control piston damping</p> <pre><code>float32 wind_curr  # -35.0..35.0\n</code></pre> </li> <li> <p>type: <code>PCBiasCurrCommand.srv</code>   topic: <code>/pc_bias_curr_command</code>   Description: Set winding bias current offset to control piston damping. This will move the piston   back and forth.</p> <pre><code>float32 bias_curr  # -15.0..15.0\n</code></pre> </li> <li> <p>type: <code>PCWindCurrCommand.srv</code>   topic: <code>/pc_wind_curr_command</code>   Description: Set winding current setpoint to control piston damping</p> <pre><code>float32 wind_curr  # -35.0..35.0\n</code></pre> </li> </ul>"},{"location":"ROS2/messages/#simulation-only-data","title":"Simulation-Only Data","text":""},{"location":"ROS2/messages/#latent-data","title":"Latent Data","text":"<ul> <li> <p>type: <code>LatentData.msg</code>   topic: <code>/latent_data</code>   Description: Latent Data provides values from the simulation that cannot be directly measured in   the physical system and are only available as byproducts of models in simulation including forces   and losses. The data are broken up into a few different data types contained within LatentData.</p> <pre><code>std_msgs/Header header  # contains time: .stamp\n\nIncWaveHeight[] inc_wave_heights\n\nAirSpring upper_spring\nAirSpring lower_spring\n\nElectroHydraulic electro_hydraulic  \n\nWaveBodyInteractions wave_body\n\nfloat64 piston_friction_force  # Newtons\n</code></pre> </li> <li> <p>type: <code>IncWaveHeight.msg</code>   topic: N/A (see <code>LatentData.msg</code>)   Description:  Wave heights at specific locations within the simulation. These positions are set   within the <code>model.sdf</code>.</p> <pre><code># relative_time is the time height was computed in decimal seconds\n# relative to simulation time in pose header.stamp\n# time of wave height = header.stamp + relative_time\n# Note: absolute_time from IncWaveHeight.srv converted to relative for response\n# Note: all fixed-points in SDF are computed with relative_time = 0.0\nfloat64 relative_time\n\n# For now, position is always in world coords (use_buoy_origin always False)\nbool use_buoy_origin\n\n# header.stamp = simulation time of computation\n#   time of wave height = header.stamp + relative_time\n# position = x, y, z(height above waterplane)\n# orientation = normal vector (slope of wave) at position\ngeometry_msgs/PoseStamped pose\n</code></pre> </li> <li> <p>type: <code>AirSpring.msg</code>   topic: N/A (see <code>LatentData.msg</code>)   Description: Air spring chamber modeling data including forces and losses</p> <pre><code>float64 force  # Newtons\nfloat64 temperature  # K\nfloat64 heat_loss  # dQ/dt in Watts\nfloat64 piston_position  # meters\nfloat64 piston_velocity  # m/s\nfloat64 mass  # kg\n</code></pre> </li> <li> <p>type: <code>ElectroHydraulic.msg</code>   topic: N/A (see <code>LatentData.msg</code>)   Description:  Electro-Hydraulic motor modeling data including forces and losses</p> <pre><code>float64 rpm\nfloat64 upper_hydraulic_pressure  # Pa \nfloat64 lower_hydraulic_pressure  # Pa \nfloat64 force  # Newtons\n\nfloat64 supplied_hydraulic_power  # Watts\n\nfloat64 hydraulic_motor_loss\nfloat64 relief_valve_loss\nfloat64 motor_emf_power  # Watts\n\nfloat64 motor_drive_i2r_loss\nfloat64 motor_drive_switching_loss\nfloat64 motor_drive_friction_loss\nfloat64 load_dump_power\nfloat64 battery_i2r_loss\nfloat64 battery_storage_power\n</code></pre> </li> <li> <p>type: <code>WaveBodyInteractions.msg</code>   topic: N/A (see <code>LatentData.msg</code>)   Description:  Hydrodynamical data including forces/torques and losses</p> <pre><code># Motion\ngeometry_msgs/Pose pose  # position/orientation\ngeometry_msgs/Twist twist  # linear/angular rates\n\n# Forces/Torques\ngeometry_msgs/Wrench buoyancy\ngeometry_msgs/Wrench radiation\ngeometry_msgs/Wrench excitation\n\n# Total power = dot(force, velocity) + dot(torque, omega)\nfloat64 buoyancy_total_power  # Watts\nfloat64 radiation_total_power  # Watts\nfloat64 excitation_total_power  # Watts\n</code></pre> </li> </ul>"},{"location":"ROS2/messages/#incident-wave-height-service","title":"Incident Wave Height Service","text":"<ul> <li> <p>type: <code>IncWaveHeight.srv</code>   topic: <code>/inc_wave_height</code>   Description: Retrieve wave heights in the simulation at various locations and times. See   <code>IncWaveHeight.msg</code> above.</p> <p>IncWaveHeight Request</p> <pre><code># relative_time in decimal seconds to evaluate height at time relative to now (0)\n# (Note: may be in future for wave prediction)\nfloat64[] relative_time\n\n# absolute_time in epoch decimal seconds (from 01/01/1970 or sim start) to evaluate height\n# (Note: may be in future for wave prediction)\nfloat64[] absolute_time\n\nbool use_relative_time\n\n# x, y is relative to buoy origin; otherwise world origin\nbool use_buoy_origin\n\n# x, y to evaluate height above waterplane\ngeometry_msgs/Point[] points\n</code></pre> <p>IncWaveHeight Response</p> <pre><code>IncWaveHeight[] heights\nbool valid\n</code></pre> </li> </ul>"},{"location":"ROS2/python_api/","title":"API (Python)","text":""},{"location":"ROS2/python_api/#buoy_apiinterface","title":"buoy_api.interface","text":""},{"location":"ROS2/python_api/#interface-objects","title":"Interface Objects","text":"<pre><code>class Interface(Node)\n</code></pre> <p>ROS2 Interface node for commanding and subscribing to buoy controllers and sensors.</p> <p>Provides service clients and functions to send commands to and receive telemetry from the MBARI WEC controllers:</p> <ul> <li>AHRS</li> <li>Power</li> <li>Spring</li> <li>Battery</li> <li>Trefoil</li> </ul> <p>If user has overridden one of these callbacks in their user-derived class, this will subscribe to the correct topic and use their callback implementation. If user did not define one, a subscriber for that topic will not be set up:</p> <ul> <li>self.ahrs_callback</li> <li>self.battery_callback</li> <li>self.spring_callback</li> <li>self.power_callback</li> <li>self.trefoil_callback</li> <li>self.powerbuoy_callback</li> </ul> <p></p>"},{"location":"ROS2/python_api/#__init__","title":"__init__","text":"<pre><code>def __init__(node_name,\n             wait_for_services=False,\n             check_for_services=True,\n             **kwargs)\n</code></pre> <p>Initialize the Interface node.</p> <p>Arguments:</p> <ul> <li><code>node_name</code> (<code>str</code>): name of the ROS2 node</li> <li><code>check_for_services</code> (<code>bool</code>): if True, attempt to verify service availability before use</li> <li><code>wait_for_services</code> (<code>bool</code>): if True and if check_for_services, block until all services are available</li> <li><code>kwargs</code>: additional keyword arguments forwarded to ROS 2 Node</li> </ul> <p></p>"},{"location":"ROS2/python_api/#use_sim_time","title":"use_sim_time","text":"<pre><code>def use_sim_time(enable=True)\n</code></pre> <p>Enable/Disable using sim time in Node clock from /clock.</p> <p>Arguments:</p> <ul> <li><code>enable</code> (<code>bool</code>): True to use /clock, False to use system time</li> </ul> <p></p>"},{"location":"ROS2/python_api/#set_pc_pack_rate_param","title":"set_pc_pack_rate_param","text":"<pre><code>def set_pc_pack_rate_param(rate_hz=50.0, blocking=True)\n</code></pre> <p>Set publish rate of PC Microcontroller telemetry.</p> <p>Arguments:</p> <ul> <li><code>rate_hz</code> (<code>float</code>): desired publish rate in Hz</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#set_sc_pack_rate_param","title":"set_sc_pack_rate_param","text":"<pre><code>def set_sc_pack_rate_param(rate_hz=50.0, blocking=True)\n</code></pre> <p>Set publish rate of SC Microcontroller telemetry.</p> <p>Arguments:</p> <ul> <li><code>rate_hz</code> (<code>float</code>): desired publish rate in Hz</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#set_pc_pack_rate","title":"set_pc_pack_rate","text":"<pre><code>def set_pc_pack_rate(rate_hz=50, blocking=True)\n</code></pre> <p>Set publish rate of PC Microcontroller telemetry.</p> <p>Arguments:</p> <ul> <li><code>rate_hz</code> (<code>float</code>): desired publish rate in Hz</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#set_sc_pack_rate","title":"set_sc_pack_rate","text":"<pre><code>def set_sc_pack_rate(rate_hz=50, blocking=True)\n</code></pre> <p>Set publish rate of SC Microcontroller telemetry.</p> <p>Arguments:</p> <ul> <li><code>rate_hz</code> (<code>float</code>): desired publish rate in Hz</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#send_pump_command","title":"send_pump_command","text":"<pre><code>def send_pump_command(duration_mins, blocking=True)\n</code></pre> <p>Turn pump on for a duration in minutes to raise mean piston position.</p> <p>Arguments:</p> <ul> <li><code>duration_mins</code> (<code>float</code>): pump on duration in minutes</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#send_valve_command","title":"send_valve_command","text":"<pre><code>def send_valve_command(duration_sec, blocking=True)\n</code></pre> <p>Turn valve on for a duration in seconds to lower mean piston position.</p> <p>Arguments:</p> <ul> <li><code>duration_sec</code> (<code>float</code>): valve on duration in seconds</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#send_pc_wind_curr_command","title":"send_pc_wind_curr_command","text":"<pre><code>def send_pc_wind_curr_command(wind_curr, blocking=True)\n</code></pre> <p>Set winding current setpoint to control piston damping.</p> <p>Arguments:</p> <ul> <li><code>wind_curr</code> (<code>float</code>): wind current setpoint in Amps</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#send_pc_bias_curr_command","title":"send_pc_bias_curr_command","text":"<pre><code>def send_pc_bias_curr_command(bias_curr, blocking=True)\n</code></pre> <p>Set bias current setpoint to control piston damping offset.</p> <p>A High bias in either direction will move the piston back and forth</p> <p>Arguments:</p> <ul> <li><code>bias_curr</code> (<code>float</code>): bias current setpoint in Amps</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#send_pc_scale_command","title":"send_pc_scale_command","text":"<pre><code>def send_pc_scale_command(scale, blocking=True)\n</code></pre> <p>Set damping gain.</p> <p>Arguments:</p> <ul> <li><code>scale</code> (<code>float</code>): damping gain</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#send_pc_retract_command","title":"send_pc_retract_command","text":"<pre><code>def send_pc_retract_command(retract, blocking=True)\n</code></pre> <p>Set additional damping gain in the piston retract direction.</p> <p>Arguments:</p> <ul> <li><code>retract</code> (<code>float</code>): additional damping gain for retraction</li> <li><code>blocking</code> (<code>bool</code>): if True, wait for the service call to complete</li> </ul> <p></p>"},{"location":"ROS2/python_api/#set_params","title":"set_params","text":"<pre><code>def set_params()\n</code></pre> <p>Set user-defined Node params (e.g. custom controller gains).</p> <p></p>"},{"location":"ROS2/python_api/#ahrs_callback","title":"ahrs_callback","text":"<pre><code>def ahrs_callback(data)\n</code></pre> <p>Override this function to subscribe to /ahrs_data to receive XBRecord telemetry.</p> <p>Arguments:</p> <ul> <li><code>data</code>: incoming XBRecord</li> </ul> <p></p>"},{"location":"ROS2/python_api/#battery_callback","title":"battery_callback","text":"<pre><code>def battery_callback(data)\n</code></pre> <p>Override this function to subscribe to /battery_data to receive BCRecord telemetry.</p> <p>Arguments:</p> <ul> <li><code>data</code>: incoming BCRecord</li> </ul> <p></p>"},{"location":"ROS2/python_api/#spring_callback","title":"spring_callback","text":"<pre><code>def spring_callback(data)\n</code></pre> <p>Override this function to subscribe to /spring_data to receive SCRecord telemetry.</p> <p>Arguments:</p> <ul> <li><code>data</code>: incoming SCRecord</li> </ul> <p></p>"},{"location":"ROS2/python_api/#power_callback","title":"power_callback","text":"<pre><code>def power_callback(data)\n</code></pre> <p>Override this function to subscribe to /power_data to receive PCRecord telemetry.</p> <p>Arguments:</p> <ul> <li><code>data</code>: incoming PCRecord</li> </ul> <p></p>"},{"location":"ROS2/python_api/#trefoil_callback","title":"trefoil_callback","text":"<pre><code>def trefoil_callback(data)\n</code></pre> <p>Override this function to subscribe to /trefoil_data to receive TFRecord telemetry.</p> <p>Arguments:</p> <ul> <li><code>data</code>: incoming TFRecord</li> </ul> <p></p>"},{"location":"ROS2/python_api/#powerbuoy_callback","title":"powerbuoy_callback","text":"<pre><code>def powerbuoy_callback(data)\n</code></pre> <p>Override this function to subscribe to /powerbuoy_data to receive PBRecord telemetry.</p> <p>PBRecord contains a slice of all microcontroller's telemetry data</p> <p>Arguments:</p> <ul> <li><code>data</code>: incoming PBRecord</li> </ul>"},{"location":"Tutorials/Install/Install_docker/","title":"Install using Docker","text":"<p>Docker images that include the neccessary software and dependencies have been created for convenience. </p>"},{"location":"Tutorials/Install/Install_docker/#requirements","title":"Requirements","text":"<ol> <li> <p>Install Docker using installation instructions.</p> </li> <li> <p>Complete the Linux Postinstall steps    to allow you to manage Docker as a non-root user.</p> </li> <li> <p>If you have an NVIDIA graphics card, it can help speed up rendering. Install    nvidia-container-toolkit.</p> <ol> <li>Follow Installation steps for Ubuntu (currently 3 steps)</li> <li>Skip down to Configuration and run <code>nvidia-ctk</code> to set up the nvidia container       runtime</li> </ol> </li> </ol>"},{"location":"Tutorials/Install/Install_docker/#use-existing-image-on-dockerhub","title":"Use Existing Image on DockerHub","text":"<p>MBARI maintains Docker images for the two most recent releases on their DockerHub:   - <code>mbari/mbari_wec:latest</code>   - <code>mbari/mbari_wec:previous</code></p> <ol> <li> <p>Get <code>run.bash</code> script.    <pre><code>git clone -b main https://github.com/osrf/mbari_wec.git\ncd ~/mbari_wec/docker/\n</code></pre>    Or    <pre><code>wget https://raw.githubusercontent.com/osrf/mbari_wec/main/docker/run.bash\nchmod +x run.bash\n</code></pre></p> </li> <li> <p>Run the container    If you have an NVIDIA graphics card    <pre><code>./run.bash mbari/mbari_wec:latest\n</code></pre>    Otherwise    <pre><code>./run.bash mbari/mbari_wec:latest --no-nvidia\n</code></pre></p> </li> <li> <p>To have another window running the same docker container, run this command in a new terminal:    <pre><code>./join.bash mbari/mbari_wec:latest\n</code></pre></p> </li> </ol>"},{"location":"Tutorials/Install/Install_docker/#build-from-dockerfile","title":"Build from Dockerfile","text":"<p>An alternative to using the images from MBARI's DockerHub would be to build from a Dockerfile. This is convenient if you would like to make any changes.</p> <ol> <li> <p>Clone the mbari_wec repository to download the latest Dockerfile.    <pre><code>git clone -b main https://github.com/osrf/mbari_wec.git\ncd ~/mbari_wec/docker/\n</code></pre></p> </li> <li> <p>Build the docker image    If you have an NVIDIA graphics card    <pre><code>./build.bash mbari_wec\n</code></pre>    Otherwise    <pre><code>./build.bash mbari_wec --no-nvidia\n</code></pre></p> </li> <li> <p>Run the container    If you have an NVIDIA graphics card    <pre><code>./run.bash mbari_wec_nvidia\n</code></pre>    Otherwise    <pre><code>./run.bash mbari_wec_no_nvidia --no-nvidia\n</code></pre></p> </li> <li> <p>To have another window running the same docker container, run this command in a new terminal:    <pre><code>./join.bash &lt;name of image&gt;\n</code></pre>    where the name of the image is one of <code>mbari_wec_nvidia</code> or <code>mbari_wec_no_nvidia</code></p> </li> </ol>"},{"location":"Tutorials/Install/Install_docker/#quick-start","title":"Quick start","text":"<p>Quick start scripts are provided in the home directory:</p> <p>This sources the compiled workspace: <pre><code>. setup.bash\n</code></pre></p> <p>This sources the compiled workspace and launches the simulation: <pre><code>./run_simulation.bash\n</code></pre></p> <p>Logs from the run will be saved to <code>/logs</code> in the container which is mapped to <code>~/mbari_wec/docker/logs</code> on the host. These logs will be in the same CSV format as generated by the physical buoy. You may also collect rosbags in the <code>/logs</code> folder in the container. The rosbags collected in the sim will also be the same ROS 2 messages collected on the physical buoy.</p>"},{"location":"Tutorials/Install/Install_docker/#run-an-example-to-test","title":"Run an example to test","text":"<ol> <li> <p>In a new terminal (whether on host machine or in Docker container), source the workspace    <pre><code>. ~/mbari_wec_ws/install/setup.bash\n</code></pre></p> </li> <li> <p>Launch the simulation    <pre><code>ros2 launch buoy_gazebo mbari_wec.launch.py\n</code></pre></p> </li> </ol> <p>The simulation software should now be available.  To run and test, proceed to the Run the Simulator tutorial series.</p>"},{"location":"Tutorials/Install/Install_source/","title":"Install from source","text":""},{"location":"Tutorials/Install/Install_source/#requirements","title":"Requirements","text":""},{"location":"Tutorials/Install/Install_source/#ubuntu-2404-ros-2-jazzy-gazebo-harmonic","title":"Ubuntu 24.04, ROS 2 Jazzy, Gazebo Harmonic","text":"<p>NOTE:</p> <p>These is the current recommended requirements. Ubuntu 22.04, ROS 2 Humble, Gazebo Garden instructions are no longer maintained for <code>mbari_wec</code> as Gazebo Garden is EOL.</p> <p>Follow instructions for Installing Gazebo with ROS.</p> <ol> <li> <p>Install ROS 2 Jazzy</p> <p>MBARI WEC is tested against the cyclonedds rmw implementation, so set that up as follows:</p> <pre><code>sudo apt install -y ros-humble-rmw-cyclonedds-cpp\nexport RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\n</code></pre> </li> <li> <p>Install Gazebo Harmonic by installing <code>ros_gz</code> from the <code>ros-jazzy-*</code> apt repos. See here for more info.</p> <p>When using Gazebo Harmonic and ROS 2 Jazzy together, <code>gz-*</code> packages come from <code>ros-jazzy-gz-*</code> apt repos. We also need to use the <code>sdformat-urdf</code> package.</p> <pre><code>sudo apt update\nsudo apt install ros-jazzy-ros-gz ros-jazzy-sdformat-urdf\n</code></pre> </li> <li> <p>Set the Gazebo version to Harmonic. (place this in ~/.bashrc for convenience if rebuilding often):</p> <pre><code>export GZ_VERSION=harmonic\n</code></pre> </li> <li> <p>gz-python-bindings</p> <p>Python bindings for <code>gz.math</code> and <code>gz.sim</code> are used in <code>mbari_wec</code> but are not distributed via apt or pip. This repository, gz-python-bindings builds the python bindings and packages them up in a simple <code>PyPI</code> index url for an easy pip install.</p> <ol> <li>Ensure these packages are also installed</li> </ol> <pre><code>sudo apt update\nsudo apt install ros-jazzy-gz-sim-vendor ros-jazzy-gz-math-vendor\n</code></pre> <ol> <li> <p>pip install</p> <p>NOTE: <code>--break-system-packages</code> might sound scary, but don't be alarmed -- nothing bad will happen in this case</p> <pre><code>python3 -m pip install -i https://mbari-org.github.io/gz-python-bindings/simple gz-python-bindings --break-system-packages\n</code></pre> </li> </ol> </li> <li> <p>Install necessary tools</p> <pre><code>sudo apt install python3-vcstool python3-colcon-common-extensions python3-pip git wget\n</code></pre> </li> <li> <p>Install necessary libraries</p> <pre><code>curl -s --compressed \"https://hamilton8415.github.io/ppa/KEY.gpg\" | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/ppa.gpg &gt;/dev/null\nsudo curl -s --compressed -o /etc/apt/sources.list.d/my_list_file.list \"https://hamilton8415.github.io/ppa/my_list_file.list\"\nsudo apt update\nsudo apt install libfshydrodynamics=1.4.0\n</code></pre> </li> </ol>"},{"location":"Tutorials/Install/Install_source/#ubuntu-2204-ros-2-humble-gazebo-garden","title":"Ubuntu 22.04, ROS 2 Humble, Gazebo Garden","text":"<p>NOTE:</p> <p>Gazebo Garden is EOL and these instructions may no longer be valid. Please use Ubuntu 24.04 with Jazzy/Harmonic.</p> <ol> <li> <p>Install ROS 2 Humble</p> <p>MBARI WEC is tested against the cyclonedds rmw implementation, so set that up as follows:</p> <pre><code>sudo apt install -y ros-humble-rmw-cyclonedds-cpp\nexport RMW_IMPLEMENTATION=rmw_cyclonedds_cpp\n</code></pre> </li> <li> <p>Install Gazebo Garden</p> </li> <li> <p>Install necessary tools</p> <pre><code>sudo apt install python3-vcstool python3-colcon-common-extensions python3-pip git wget\n</code></pre> </li> <li> <p>Install necessary libraries</p> <pre><code>curl -s --compressed \"https://hamilton8415.github.io/ppa/KEY.gpg\" | gpg --dearmor | sudo tee /etc/apt/trusted.gpg.d/ppa.gpg &gt;/dev/null\nsudo curl -s --compressed -o /etc/apt/sources.list.d/my_list_file.list \"https://hamilton8415.github.io/ppa/my_list_file.list\"\nsudo apt update\nsudo apt install libfshydrodynamics=1.3.1\n</code></pre> </li> <li> <p>Set the Gazebo version to Garden. This is needed because we're not using an    official ROS + Gazebo combination (place this in ~/.bashrc for convenience if rebuilding often):</p> <pre><code>export GZ_VERSION=garden\n</code></pre> </li> </ol>"},{"location":"Tutorials/Install/Install_source/#buoy-simulation-software-build","title":"Buoy Simulation Software Build","text":"<ol> <li> <p>Create a workspace, for example:</p> <pre><code>mkdir -p ~/mbari_wec_ws/src\ncd ~/mbari_wec_ws/src\n</code></pre> </li> <li> <p>Clone all source repos with the help of <code>vcstool</code>:</p> <pre><code>wget https://raw.githubusercontent.com/osrf/mbari_wec/main/mbari_wec_all.yaml\nvcs import &lt; mbari_wec_all.yaml\ncd ~/mbari_wec_ws\n</code></pre> </li> <li> <p>Install ROS dependencies</p> <pre><code>sudo pip3 install -U rosdep\nsudo rosdep init\nrosdep update\nrosdep install --from-paths src --ignore-src -r -y -i\n</code></pre> </li> <li> <p>Build and install</p> <pre><code>source /opt/ros/humble/setup.bash\ncd ~/mbari_wec_ws\ncolcon build\n</code></pre> </li> </ol> <p>The simulation software should build without errors.  To run and test, proceed to the    Run the Simulator tutorial series.  Or run a quick    test as described below to confirm all has worked as expected.</p>"},{"location":"Tutorials/Install/Install_source/#run-an-example-to-test","title":"Run an example to test","text":"<ol> <li> <p>In a new terminal, source the workspace</p> <pre><code>. ~/mbari_wec_ws/install/setup.bash\n</code></pre> </li> <li> <p>Set <code>SDF_PATH</code> to allow <code>robot_state_publisher</code> parse the robot description    from the sdformat model (place this in ~/.bashrc for convenience if rebuilding often):</p> </li> </ol> <pre><code>export SDF_PATH=$GZ_SIM_RESOURCE_PATH\n</code></pre> <ol> <li> <p>Launch the simulation</p> <pre><code>ros2 launch buoy_gazebo mbari_wec.launch.py\n</code></pre> </li> </ol>"},{"location":"Tutorials/ROS2/CppLinearDamperExample/","title":"Quick Start -- Simple Linear Damper Controller (C++)","text":"<p>In this tutorial you will implement a simple linear damper controller for the piston in the WEC Power-Take-Off (PTO). Given motor RPM, it outputs desired motor winding current (interpolated from RPM-&gt;Torque lookup table) to generate a torque to resist piston velocity with a damping force. Configurable gains (scale/retract factor) are applied before output. In the end, you will have a working linear damper controller that is very close to the controller running on both the physical and simulated buoy.</p>"},{"location":"Tutorials/ROS2/CppLinearDamperExample/#prerequisite","title":"Prerequisite","text":"<p>This tutorial assumes you are familiar the steps from the previous tutorial and have built your own custom C++ ROS 2 controller package from the mbari_wec_template_cpp template repository which we will use to implement a simple linear damper controller.</p> <p>To begin, you should have a C++ ROS 2 controller package that looks similar to:</p> <pre><code>mbari_wec_linear_damper_cpp\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 config\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.yaml\n    \u251c\u2500\u2500 include\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 mbari_wec_linear_damper_cpp\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 controller.hpp\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 control_policy.hpp\n    \u251c\u2500\u2500 launch\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.launch.py\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 package.xml\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 src\n        \u2514\u2500\u2500 controller.cpp\n</code></pre> <p>with the files modified from the previous tutorial. If you haven't already, follow the steps in the above mentioned link to create a package for this tutorial named <code>mbari_wec_linear_damper_cpp</code>.</p>"},{"location":"Tutorials/ROS2/CppLinearDamperExample/#linear-damper-controlpolicy","title":"Linear Damper ControlPolicy","text":"<p>A complete example starting from the template may be found here. Line numbers in this tutorial correspond to the lines in relevant files in the full example.</p>"},{"location":"Tutorials/ROS2/CppLinearDamperExample/#parameters","title":"Parameters","text":"<p>Parameters for the controller are:</p> <ul> <li><code>torque_constant</code>: Motor Torque Constant (N-m/Amp)   Constant to convert desired torque to applied motor winding current  </li> <li><code>n_spec</code>: Input Motor Speed (RPM) Breakpoints  (RPM) is the input to the controller and <code>n_spec</code> are the x-components of the breakpoints    for the interpolant, </li> <li><code>torque_spec</code>: Desired Output Motor Torque (N-m) Breakpoints   Torque (N-m) is the eventual desired output of the controller given an input <code>N</code> (motor RPM) and   <code>torque_spec</code> / <code>torque_constant</code> (Amps) are the y-components of the breakpoints for the   interpolant. The controller actually outputs motor winding current (Amps) to generate a torque   in the opposite direction of piston velocity to generate a damping force.</li> </ul> <p>These can be configured using the <code>config/controller.yaml</code> file.</p> config/controller.yaml<pre><code>/linear_damper:\n  ros__parameters:\n    torque_constant: 0.438\n    n_spec: [0.0, 300.0, 600.0, 1000.0, 1700.0, 4400.0, 6790.0]\n    torque_spec: [0.0, 0.0, 0.8, 2.9, 5.6, 9.8, 16.6]\n</code></pre> <p>As you can see, as motor speed increases, so does the damping torque. For low RPM (up to 300), there is no damping.</p> <p>Initialize these variables and create the interpolator, <code>winding_current</code>, in <code>ControlPolicy</code> in <code>include/mbari_wec_linear_damper_cpp/control_policy.hpp</code>. This example makes use of <code>&lt;simple_interp/interp1d.hpp&gt;</code> from <code>mbari_wec_utils</code>, so don't forget to include that as well as <code>&lt;algorithm&gt;</code> and <code>&lt;vector&gt;</code>.</p> include/mbari_wec_linear_damper_cpp/control_policy.hpp<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\n#include &lt;mbari_wec_linear_damper_cpp/controller.hpp&gt;\n\n// interp1d for rpm-&gt;winding current\n#include &lt;simple_interp/interp1d.hpp&gt;\n\n\n/* Simple Linear Damper Control Policy.\n     Implements a simple linear damper controller for the piston in the WEC\n     Power-Take-Off (PTO). Given motor RPM, outputs desired motor winding current (interpolated\n     from RPM-&gt;Torque lookup table) to resist piston velocity. Configurable gains\n     (scale/retract factor) are applied before output.\n*/\nstruct ControlPolicy\n{\n  // declare/init any parameter variables here\n  double Torque_constant;  // N-m/Amps\n  std::vector&lt;double&gt; N_Spec;  // RPM\n  std::vector&lt;double&gt; Torque_Spec;  // N-m\n  std::vector&lt;double&gt; I_Spec;  // Amps\n\n  // interpolator for rpm -&gt; winding current\n  simple_interp::Interp1d winding_current;\n\n  ControlPolicy()\n  : Torque_constant(0.438F),\n    N_Spec{0.0F, 300.0F, 600.0F, 1000.0F, 1700.0F, 4400.0F, 6790.0F},\n    Torque_Spec{0.0F, 0.0F, 0.8F, 2.9F, 5.6F, 9.8F, 16.6F},\n    I_Spec(Torque_Spec.size(), 0.0F),\n    winding_current(N_Spec, I_Spec)\n  {\n    update_params();\n  }\n</code></pre> <p>Update the dependent variable, <code>I_Spec</code>, as well as the interpolator, <code>winding_current</code>.</p> include/mbari_wec_linear_damper_cpp/control_policy.hpp<pre><code>  // Update dependent variables after reading in params\n  void update_params()\n  {\n    std::transform(\n      Torque_Spec.cbegin(), Torque_Spec.cend(),\n      I_Spec.begin(),\n      [tc = Torque_constant](const double &amp; ts) {return ts / tc;});\n\n    winding_current.update(N_Spec, I_Spec);\n  }\n</code></pre> <p>Finally, define the <code>set_params</code> function of the <code>Controller</code> class and declare/get/set/update these parameters from ROS 2 (as set in <code>config/controller.yaml</code>).</p> include/mbari_wec_linear_damper_cpp/control_policy.hpp<pre><code>// Use ROS2 declare_parameter and get_parameter to set policy params\nvoid Controller::set_params()\n{\n  this-&gt;declare_parameter(\"torque_constant\", policy_-&gt;Torque_constant);\n  policy_-&gt;Torque_constant = this-&gt;get_parameter(\"torque_constant\").as_double();\n\n  this-&gt;declare_parameter(\n    \"n_spec\", std::vector&lt;double&gt;(\n      policy_-&gt;N_Spec.begin(),\n      policy_-&gt;N_Spec.end()));\n  std::vector&lt;double&gt; temp_double_arr = this-&gt;get_parameter(\"n_spec\").as_double_array();\n  policy_-&gt;N_Spec.assign(temp_double_arr.begin(), temp_double_arr.end());\n\n  this-&gt;declare_parameter(\n    \"torque_spec\", std::vector&lt;double&gt;(\n      policy_-&gt;Torque_Spec.begin(),\n      policy_-&gt;Torque_Spec.end()));\n  temp_double_arr = this-&gt;get_parameter(\"torque_spec\").as_double_array();\n  policy_-&gt;Torque_Spec.assign(temp_double_arr.begin(), temp_double_arr.end());\n\n  // recompute any dependent variables\n  policy_-&gt;update_params();\n  RCLCPP_INFO_STREAM(rclcpp::get_logger(this-&gt;get_name()), *policy_);\n}\n</code></pre> <p>Add a helper function, for the <code>ControlPolicy</code> class for this example to report the parameters used.</p> include/mbari_wec_linear_damper_cpp/control_policy.hpp<pre><code>// Helper function to print policy parameters\nstd::ostream &amp; operator&lt;&lt;(std::ostream &amp; os, const ControlPolicy &amp; policy)\n{\n  os &lt;&lt; \"ControlPolicy:\" &lt;&lt; std::endl;\n\n  os &lt;&lt; \"\\tTorque_constant: \" &lt;&lt; policy.Torque_constant &lt;&lt; std::endl;\n\n  os &lt;&lt; \"\\tN_Spec: \" &lt;&lt; std::flush;\n  std::copy(policy.N_Spec.cbegin(), policy.N_Spec.cend(), std::ostream_iterator&lt;double&gt;(os, \",\"));\n  os &lt;&lt; \"\\b \\b\" &lt;&lt; std::endl;\n\n  os &lt;&lt; \"\\tTorque_Spec: \" &lt;&lt; std::flush;\n  std::copy(\n    policy.Torque_Spec.cbegin(),\n    policy.Torque_Spec.cend(),\n    std::ostream_iterator&lt;double&gt;(os, \",\"));\n  os &lt;&lt; \"\\b \\b\" &lt;&lt; std::endl;\n\n  os &lt;&lt; \"\\tI_Spec: \" &lt;&lt; std::flush;\n  std::copy(policy.I_Spec.cbegin(), policy.I_Spec.cend(), std::ostream_iterator&lt;double&gt;(os, \",\"));\n  os &lt;&lt; \"\\b \\b\" &lt;&lt; std::endl;\n\n  return os;\n}\n</code></pre>"},{"location":"Tutorials/ROS2/CppLinearDamperExample/#control-policy-target","title":"Control Policy Target","text":"<p>To implement the torque control control policy, we use the <code>target</code> function in <code>ControlPolicy</code>. This is where we accept feedback data and return a command value. In this case, we need the motor <code>rpm</code>, and the gains applied to the winding current damping, <code>scale_factor</code> and <code>retract_factor</code>. Typical values for these gains are</p> <ul> <li>scale_factor = 1</li> <li>retract_factor = 0.6</li> </ul> include/mbari_wec_linear_damper_cpp/control_policy.hpp<pre><code>  // Calculate target value from feedback inputs\n  double target(\n    const double &amp; rpm,\n    const double &amp; scale_factor,\n    const double &amp; retract_factor)\n  {\n    double N = fabs(rpm);\n    double I = winding_current.eval(N);\n\n    // apply damping gain\n    I *= scale_factor;\n\n    // Hysteresis due to gravity / wave assist\n    if (rpm &gt; 0.0F) {\n      I *= -retract_factor;\n    }\n\n    return I;\n  }\n</code></pre> <p>So, as you can see we apply a positive damping torque when RPM is negative (piston extending), and a positive damping torque when RPM is positive (piston retracting). The damping torque required is reduced when retracting.</p>"},{"location":"Tutorials/ROS2/CppLinearDamperExample/#controller","title":"Controller","text":"<p>All that is left is to connect the necessary feedback data to the <code>ControlPolicy</code>. In this case, <code>rpm</code>, <code>scale</code>, and <code>retract</code> are present in <code>buoy_interfaces.msg.PCRecord</code> on the <code>/power_data</code> topic published by the Power Controller running on the buoy.</p> <p>To access the data, all that is required is to define the callback <code>void Controller::power_callback(const buoy_interfaces::msg::PCRecord &amp; data)</code> in the <code>Controller</code> class, and pass the data to <code>this-&gt;policy_-&gt;target</code> to get the desired winding current command. Various commands are available, and this time we will be using <code>this-&gt;send_pc_wind_curr_command(wind_curr_amps);</code></p> src/controller.cpp<pre><code>// Callback for '/power_data' topic from Power Controller\nvoid Controller::power_callback(const buoy_interfaces::msg::PCRecord &amp; data)\n{\n  // Update class variables, get control policy target, send commands, etc.\n  // get target value from control policy\n  double wind_curr = this-&gt;policy_-&gt;target(data.rpm, data.scale, data.retract);\n\n  RCLCPP_INFO_STREAM(\n    rclcpp::get_logger(\n      this-&gt;get_name()),\n    \"WindingCurrent: f(\" &lt;&lt; data.rpm &lt;&lt; \", \" &lt;&lt; data.scale &lt;&lt; \", \" &lt;&lt; data.retract &lt;&lt; \") = \" &lt;&lt;\n      wind_curr);\n\n  auto future = this-&gt;send_pc_wind_curr_command(wind_curr);\n}\n</code></pre> <p>Finally, let's set the Power Controller's publish rate to the maximum of 50Hz. Uncomment the line to set the PC Pack Rate in <code>Controller</code> constructor:</p> src/controller.cpp<pre><code>Controller::Controller(const std::string &amp; node_name)\n: buoy_api::Interface&lt;Controller&gt;(node_name),\n  policy_(std::make_unique&lt;ControlPolicy&gt;())\n{\n  this-&gt;set_params();\n\n  // set packet rates from controllers here\n  // controller defaults to publishing @ 10Hz\n  // call these to set rate to 50Hz or provide argument for specific rate\n  // this-&gt;set_sc_pack_rate();  // set SC publish rate to 50Hz\n  this-&gt;set_pc_pack_rate();  // set PC publish rate to 50Hz\n}\n</code></pre> <p>In this tutorial, we've named this controller <code>linear_damper</code>. Don't forget to update controller names along with other changes according to the previous tutorial.</p>"},{"location":"Tutorials/ROS2/CppLinearDamperExample/#try-it-out","title":"Try It Out","text":"<p>Make sure to build and source your workspace. This tutorial assumes you cloned your package to <code>~/controller_ws/src</code> and you have sourced <code>mbari_wec_gz</code> and <code>mbari_wec_utils</code> <pre><code>$ cd ~/controller_ws\n$ colcon build\n$ source install/local_setup.bash\n</code></pre></p> <p>We will be using <code>ros2 launch</code> and <code>launch/controller.launch.py</code> to run our new controller.</p> <p>To run the controller along with the simulation, launch your controller: <code>$ ros2 launch mbari_wec_linear_damper_cpp controller.launch.py</code></p> <p>Then, in another terminal (with <code>mbari_wec_gz</code> sourced), launch the sim: <code>$ ros2 launch buoy_gazebo mbari_wec.launch.py</code> and click the play button.</p> <p>You should see output similar to:</p> <pre><code>[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.623306255] [mbari_wec_linear_damper_cpp]: Found all required services.\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.623437968] [mbari_wec_linear_damper_cpp]: ControlPolicy:\n[mbari_wec_linear_damper_cpp-1]         Torque_constant: 0.438\n[mbari_wec_linear_damper_cpp-1]         N_Spec: 0,300,600,1000,1700,4400,6790\n[mbari_wec_linear_damper_cpp-1]         Torque_Spec: 0,0,0.8,2.9,5.6,9.8,16.6\n[mbari_wec_linear_damper_cpp-1]         I_Spec: 0,0,1.82648,6.621,12.7854,22.3744,37.8995\n[mbari_wec_linear_damper_cpp-1]\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.623585767] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2911.62, 1, 0.6) = -10.2531\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.623769091] [mbari_wec_linear_damper_cpp]: Successfully set publish_rate for power_controller\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.723139301] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2881.34, 1, 0.6) = -10.1886\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.723199020] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2881.34, 1, 0.6) = -10.1886\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.743295542] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2864.91, 1, 0.6) = -10.1535\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.763406662] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2845.41, 1, 0.6) = -10.112\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.783518884] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2822.43, 1, 0.6) = -10.063\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.803625212] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2796.29, 1, 0.6) = -10.0073\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.823736947] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2767.06, 1, 0.6) = -9.94502\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.843817290] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2734.81, 1, 0.6) = -9.87631\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.863931284] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2699.67, 1, 0.6) = -9.80143\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.884041064] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2661.74, 1, 0.6) = -9.7206\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.904159386] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2621.09, 1, 0.6) = -9.63398\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.924232170] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2577.85, 1, 0.6) = -9.54184\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.944361837] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2532.15, 1, 0.6) = -9.44445\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.964467851] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2484.08, 1, 0.6) = -9.34203\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215528.984588134] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2433.76, 1, 0.6) = -9.23479\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215529.004697490] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2381.3, 1, 0.6) = -9.12301\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215529.024807195] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2326.81, 1, 0.6) = -9.00691\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215529.044928940] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2270.4, 1, 0.6) = -8.88669\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215529.065039660] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2212.17, 1, 0.6) = -8.76262\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215529.085145551] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2152.24, 1, 0.6) = -8.63491\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215529.105256007] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2090.71, 1, 0.6) = -8.50379\n[mbari_wec_linear_damper_cpp-1] [INFO] [1680215529.125363653] [mbari_wec_linear_damper_cpp]: WindingCurrent: f(2027.67, 1, 0.6) = -8.36947\n</code></pre>"},{"location":"Tutorials/ROS2/CppOpenLoopControl/","title":"Open-Loop Force Command Example (C++)","text":""},{"location":"Tutorials/ROS2/CppTemplate/","title":"Quick Start \u2014 Writing External Controller With GitHub Template Repository","text":"<p>In this tutorial, you will make and customize a GitHub repository from a GitHub Template with a ROS 2 C++ package and code ready to implement your own external controller utilizing the <code>buoy_api_cpp</code> interface. This interface may be used with the both the simulated and physical buoy.</p>"},{"location":"Tutorials/ROS2/CppTemplate/#interfaces-and-templates","title":"Interfaces and Templates","text":"<p>There are two GitHub template repositories set up (C++/Python) for a quick start on writing a custom controller utilizing buoy_api_cpp and buoy_api_py. Please see C++ examples and Python examples for example controller implementations.</p> <ul> <li>mbari_wec_template_cpp</li> <li>mbari_wec_template_py</li> </ul>"},{"location":"Tutorials/ROS2/CppTemplate/#using-c-template","title":"Using C++ Template","text":""},{"location":"Tutorials/ROS2/CppTemplate/#creating-your-own-repo-from-the-template","title":"Creating your own repo from the template","text":"<p>You may also refer to GitHub's template documentation</p> <p>To start using the C++ GitHub template</p> <ol> <li> <p>Navigate to mbari_wec_template_cpp and click the green button with the text <code>Use this template</code> and select <code>Create a new repository</code></p> <p></p> </li> <li> <p>Next, set up the repository like you would any new GitHub repository choosing the owner, repository name, public/private, etc.</p> </li> <li> <p>Make a ROS 2 workspace <pre><code>$ mkdir -p ~/controller_ws/src\n$ cd ~/controller_ws/src\n</code></pre></p> </li> <li> <p>Now that your new repository is set up, clone it to your local machine, make a branch, etc. <pre><code>$ git clone https://github.com/&lt;owner&gt;/&lt;repo_name&gt;.git\n$ cd ~/controller_ws\n</code></pre></p> </li> </ol> <p>You should now have a C++ ROS 2 package with the following structure in your workspace <code>src</code>:</p> <pre><code>&lt;repo_name&gt;\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 config\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.yaml\n    \u251c\u2500\u2500 include\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 mbari_wec_template_cpp\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 controller.hpp\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 control_policy.hpp\n    \u251c\u2500\u2500 launch\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.launch.py\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 package.xml\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 src\n        \u2514\u2500\u2500 controller.cpp\n</code></pre>"},{"location":"Tutorials/ROS2/CppTemplate/#customizing-the-controller","title":"Customizing the controller","text":"<p>You may also refer to the <code>README.md</code> in your newly cloned repository.</p>"},{"location":"Tutorials/ROS2/CppTemplate/#modify-template-for-your-package","title":"Modify template for your package","text":"<p>Replace <code>mbari_wec_template_cpp</code> with your package name and modify other fields as necessary in:</p> <ul> <li><code>package.xml</code> (lines 4-8)</li> </ul> package.xml<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;repo_name&lt;/name&gt;  &lt;!-- Update package name --&gt;\n  &lt;version&gt;3.14&lt;/version&gt;  &lt;!-- Update version --&gt;\n  &lt;description&gt;Your Controller Description&lt;/description&gt;  &lt;!-- Update description --&gt;\n  &lt;maintainer email=\"your@email\"&gt;Your Name&lt;/maintainer&gt;  &lt;!-- Update email and name --&gt;\n  &lt;license&gt;Your License&lt;/license&gt;  &lt;!-- Update license --&gt;\n</code></pre> <ul> <li><code>CMakeLists.txt</code> (line 2)</li> </ul> CMakeLists.txt<pre><code>cmake_minimum_required(VERSION 3.8)\nproject(mbari_wec_template_cpp)  # Update ${PROJECT_NAME}\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\")\n  add_compile_options(-Wall -Wextra -Wpedantic)\nendif()\n\n# find dependencies\nfind_package(ament_cmake REQUIRED)\nfind_package(rclcpp REQUIRED)\nfind_package(buoy_interfaces REQUIRED)\nfind_package(buoy_api_cpp REQUIRED COMPONENTS buoy_api)\n\nadd_executable(${PROJECT_NAME} src/controller.cpp)\ntarget_link_libraries(${PROJECT_NAME} PUBLIC buoy_api_cpp::buoy_api)\nament_target_dependencies(${PROJECT_NAME} PUBLIC rclcpp buoy_interfaces)\ntarget_include_directories(${PROJECT_NAME} PUBLIC\n  $&lt;BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include&gt;\n  $&lt;INSTALL_INTERFACE:include&gt;)\ntarget_compile_features(${PROJECT_NAME} PUBLIC c_std_99 cxx_std_17)  # Require C99 and C++17\n</code></pre> <ul> <li><code>launch/controller.launch.py</code> (line 22)     Update <code>package_name</code> and node name with your controller name (same as the name in      <code>config/controller.yaml</code>)</li> </ul> launch/controller.launch.py<pre><code>package_name = 'your_package_name'   # Update package name (same as in CMakeLists.txt)\n\ndef generate_launch_description():\n    ld = LaunchDescription()\n    config = os.path.join(\n        get_package_share_directory(package_name),\n        'config',\n        'controller.yaml'\n        )\n\n    node = Node(\n        package=package_name,\n        name='your_controller_name',  # ensure same as name in config.yaml\n        executable=package_name,\n</code></pre> <ul> <li><code>config/controller.yaml</code> (line 1)     Update first line with your controller name (same as node name in launch file)</li> </ul> config/controller.yaml<pre><code>/your_controller_name:\n  ros__parameters:\n    foo: 1.0\n</code></pre> <p>and rename the folder:</p> <ul> <li><code>include/mbari_wec_template_cpp</code> (containing <code>controller.hpp</code> and <code>control_policy.hpp</code>) to your   package name</li> </ul> <p>resulting in the following folder structure:</p> <pre><code>&lt;your_package_name&gt;\n    \u251c\u2500\u2500 CMakeLists.txt\n    \u251c\u2500\u2500 config\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.yaml\n    \u251c\u2500\u2500 include\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 &lt;your_package_name&gt;\n    \u2502\u00a0\u00a0     \u251c\u2500\u2500 controller.hpp\n    \u2502\u00a0\u00a0     \u2514\u2500\u2500 control_policy.hpp\n    \u251c\u2500\u2500 launch\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.launch.py\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 package.xml\n    \u251c\u2500\u2500 README.md\n    \u2514\u2500\u2500 src\n        \u2514\u2500\u2500 controller.cpp\n</code></pre> <p>Update the include paths in:</p> <ul> <li> <p><code>controller.cpp</code> (lines 18-19) src/controller.cpp<pre><code>#include &lt;mbari_wec_template_cpp/control_policy.hpp&gt;  // update include path\n#include &lt;mbari_wec_template_cpp/controller.hpp&gt;  // update include path\n</code></pre></p> </li> <li> <p><code>control_policy.hpp</code> (line 22) include/your_package_name/control_policy.hpp<pre><code>#include &lt;mbari_wec_template_cpp/controller.hpp&gt;  // update include path\n</code></pre></p> </li> </ul> <p>Also, update include guards:</p> <ul> <li> <p><code>control_policy.hpp</code> include/your_package_name/control_policy.hpp<pre><code>#ifndef YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_\n#define YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_\n</code></pre> <code>...</code> \u200b<pre><code>#endif  // YOUR_PACKAGE_NAME__CONTROL_POLICY_HPP_\n</code></pre></p> </li> <li> <p><code>controller.hpp</code> include/your_package_name/controller.hpp<pre><code>#ifndef YOUR_PACKAGE_NAME__CONTROLLER_HPP_\n#define YOUR_PACKAGE_NAME__CONTROLLER_HPP_\n</code></pre> <code>...</code> \u200b<pre><code>#endif  // YOUR_PACKAGE_NAME__CONTROLLER_HPP_\n</code></pre></p> </li> </ul> <p>Modify <code>CMakeLists.txt</code> as desired and add any dependencies in <code>package.xml</code> following standard ROS 2 documentation.</p>"},{"location":"Tutorials/ROS2/CppTemplate/#implement-controller","title":"Implement Controller","text":"<p>Assuming you have followed the above,</p> <ul> <li><code>include/&lt;your_package_name&gt;/control_policy.hpp</code></li> <li><code>src/controller.cpp</code></li> </ul> <p>are stubbed out to implement your custom external controller. You may also use <code>config/controller.yaml</code> for any policy parameters.</p>"},{"location":"Tutorials/ROS2/CppTemplate/#controlpolicy","title":"ControlPolicy","text":"<p>You may use the struct <code>ControlPolicy</code> in <code>control_policy.hpp</code> to implement your controller.</p> include/your_package_name/control_policy.hpp<pre><code>struct ControlPolicy\n{\n  // declare/init any parameter variables here\n  double foo{1.0};\n  double bar{10.0*foo};\n\n  ControlPolicy()\n  : foo{1.0},\n    bar{10.0*foo}\n  {\n    update_params();\n  }\n\n  // Update dependent variables after reading in params\n  void update_params()\n  {\n    bar = 10.0*foo;\n  }\n\n  // Modify function inputs as desired\n  // Calculate target value from feedback inputs\n  double target(\n    const double &amp; /*some*/,\n    const double &amp; /*feedback*/,\n    const double &amp; /*values*/)\n  {\n\n    // secret sauce\n\n    return 0.0;  // obviously, modify to return proper target value\n  }\n};\n</code></pre> <ul> <li>Declare/define any configurable parameters in the struct and init list</li> </ul> include/your_package_name/control_policy.hpp<pre><code>  // declare/init any parameter variables here\n  double foo{1.0};\n  double bar{10.0*foo};\n\n  ControlPolicy()\n  : foo{1.0},\n    bar{10.0*foo}\n</code></pre> <ul> <li>Set any dependent variables in <code>update_params</code> on line 39</li> </ul> include/your_package_name/control_policy.hpp<pre><code>  // Update dependent variables after reading in params\n  void update_params()\n  {\n    bar = 10.0*foo;\n  }\n</code></pre> <ul> <li>Declare/get/update params in the <code>set_params</code> function of the <code>Controller</code> class on line 58</li> </ul> include/your_package_name/control_policy.hpp<pre><code>// Use ROS2 declare_parameter and get_parameter to set policy params\nvoid Controller::set_params()\n{\n  this-&gt;declare_parameter(\"foo\", policy_-&gt;foo);\n  policy_-&gt;foo = this-&gt;get_parameter(\"foo\").as_double();\n\n  // recompute any dependent variables\n  policy_-&gt;update_params();\n}\n</code></pre> <ul> <li>Then, your control logic will go in the <code>target</code> function on line 46.     Modify the input args as well as the return value as necessary</li> </ul> include/your_package_name/control_policy.hpp<pre><code>  // Modify function inputs as desired\n  // Calculate target value from feedback inputs\n  double target(\n    const double &amp; /*some*/,\n    const double &amp; /*feedback*/,\n    const double &amp; /*values*/)\n  {\n\n    // secret sauce\n\n    return 0.0;  // obviously, modify to return proper target value\n  }\n</code></pre>"},{"location":"Tutorials/ROS2/CppTemplate/#controller","title":"Controller","text":"<p>The <code>Controller</code> class contains an instance of <code>ControlPolicy</code> as the member variable, <code>this-&gt;policy</code>. The <code>this-&gt;policy-&gt;target</code> function may be called anywhere within the <code>Controller</code> class. You may call it inside any of the data callbacks to enable feedback control (for example):</p> (EXAMPLE) include/your_package_name/controller.hpp<pre><code>  // To subscribe to any topic, simply declare &amp; define the specific callback, e.g. power_callback\n\n  // Callback for '/power_data' topic from Power Controller\n  void power_callback(const buoy_interfaces::msg::PCRecord &amp; data)\n  {\n    // get target value from control policy\n    double wind_curr = policy_-&gt;target(data.rpm, data.scale, data.retract);\n\n      auto future = this-&gt;send_pc_wind_curr_command(wind_curr);\n  }\n</code></pre> <p>Or, set up a loop in <code>main</code> and run open-loop:</p> (EXAMPLE) src/controller.cpp<pre><code>int main(int argc, char ** argv)\n{\n  rclcpp::init(argc, argv);\n\n  auto controller = std::make_shared&lt;Controller&gt;(\"controller\");\n  rclcpp::Rate rate(50.0);\n  while (rclcpp::ok()) {\n    rclcpp::spin_once(controller);\n    rate.sleep();\n  }\n  rclcpp::shutdown();\n\n  return 0;\n}\n</code></pre> <p>You may get feedback data from any of the buoy topics by simply creating a specific callback listed below. For feedback data you'd like to use in another area of the class, feel free to assign them to class variables.</p> <p>(Delete any callbacks you don't need in the <code>Controller</code> class)</p> <p>Available callback functions:</p> <p><code>/ahrs_data</code> \u2192 <code>void ahrs_callback(const buoy_interfaces::msg::XBRecord &amp; data){}</code> <code>/battery_data</code> \u2192 <code>void battery_callback(const buoy_interfaces::msg::BCRecord &amp; data){}</code> <code>/spring_data</code> \u2192 <code>void spring_callback(const buoy_interfaces::msg::SCRecord &amp; data){}</code> <code>/power_data</code> \u2192 <code>void power_callback(const buoy_interfaces::msg::PCRecord &amp; data){}</code> <code>/trefoil_data</code> \u2192 <code>void trefoil_callback(const buoy_interfaces::msg::TFRecord &amp; data){}</code> <code>/powerbuoy_data</code> \u2192 <code>void powerbuoy_callback(const buoy_interfaces::msg::PBRecord &amp; data){}</code> </p> <p>You may also send commands from within the <code>Controller</code> class:</p> <p><code>this-&gt;send_pump_command(duration_mins);</code> <code>this-&gt;send_valve_command(duration_sec);</code> <code>this-&gt;send_pc_wind_curr_command(wind_curr_amps);</code> <code>this-&gt;send_pc_bias_curr_command(bias_curr_amps);</code> <code>this-&gt;send_pc_scale_command(scale_factor);</code> <code>this-&gt;send_pc_retract_command(retract_factor);</code> </p> <p>In the <code>Controller</code> constructor, you may also uncomment lines 31 or 32 to set the publish rates for the Spring or Power Controllers on the buoy. These controllers default to publishing feedback at 10Hz to conserve data/bandwidth (on the physical buoy). For feedback control, you have the option to increase the publish rate. You can call commands to set the rates anywhere from 10Hz to 50Hz (default argument is 50Hz).</p> src/controller.cpp<pre><code>Controller::Controller(const std::string &amp; node_name)\n: buoy_api::Interface&lt;Controller&gt;(node_name),\n  policy_(std::make_unique&lt;ControlPolicy&gt;())\n{\n  this-&gt;set_params();\n\n  // set packet rates from controllers here\n  // controller defaults to publishing @ 10Hz\n  // call these to set rate to 50Hz or provide argument for specific rate\n  // this-&gt;set_sc_pack_rate();  // set SC publish rate to 50Hz\n  // this-&gt;set_pc_pack_rate();  // set PC publish rate to 50Hz\n</code></pre> <p>The <code>Controller</code> is also capable of synchronizing its clock from the sim <code>/clock</code> by uncommenting line 36. Since the <code>Controller</code> inherits from <code>rclcpp::Node</code>, you may use <code>this-&gt;get_clock()</code> and other various time-related functions of <code>rclcpp::Node</code>.</p> <pre><code>  // Use this to set node clock to use sim time from /clock (from gazebo sim time)\n  // Access node clock via this-&gt;get_clock() or other various time-related functions of rclcpp::Node\n  // this-&gt;use_sim_time();\n</code></pre>"},{"location":"Tutorials/ROS2/CppTemplate/#build-test-run","title":"Build, Test, Run","text":"<p>At this point, your new package should build, pass tests, and run against the sim (will connect but do nothing).</p> <p>It is assumed that you have already installed or built the buoy packages.</p> <p>From your workspace (e.g. <code>~/controller_ws</code>) build your package: <pre><code>$ colcon build\nStarting &gt;&gt;&gt; mbari_wec_template_cpp\nFinished &lt;&lt;&lt; mbari_wec_template_cpp [25.0s]\n\nSummary: 1 package finished [25.2s]\n</code></pre> You may also build only your new controller package (if you have other packages in the workspace) using: <code>$ colcon build --packages-up-to &lt;your_package_name&gt;</code></p> <p>Then, source and test: <pre><code>$ source install/local_setup.bash\n$ colcon test\nStarting &gt;&gt;&gt; mbari_wec_template_cpp\nFinished &lt;&lt;&lt; mbari_wec_template_cpp [1.38s]\n\nSummary: 1 package finished [1.54s]\n</code></pre> Or, you may test only your new controller package using: <code>$ colcon test --packages-select &lt;your_package_name&gt;</code></p> <p>Next, in another terminal run the sim (after sourcing the sim packages of course): <code>$ ros2 launch buoy_gazebo mbari_wec.launch.py</code></p> <p>Now, in the previous terminal, launch the empty controller: <pre><code>$ ros2 launch &lt;your_package_name&gt; controller.launch.py\n</code></pre></p> <p>And you should see something similar to: <pre><code>[INFO] [launch]: Default logging verbosity is set to INFO\n[INFO] [mbari_wec_template_cpp-1]: process started with pid [1297902]\n[mbari_wec_template_cpp-1] [INFO] [1678127525.594948064] [mbari_wec_template_cpp]: Subscribing to XBRecord on '/ahrs_data' and '/xb_record'\n[mbari_wec_template_cpp-1] [INFO] [1678127525.595508167] [mbari_wec_template_cpp]: Subscribing to BCRecord on '/battery_data' and '/bc_record'\n[mbari_wec_template_cpp-1] [INFO] [1678127525.595795098] [mbari_wec_template_cpp]: Subscribing to SCRecord on '/spring_data' and '/sc_record'\n[mbari_wec_template_cpp-1] [INFO] [1678127525.596027219] [mbari_wec_template_cpp]: Subscribing to PCRecord on '/power_data' and '/pc_record'\n[mbari_wec_template_cpp-1] [INFO] [1678127525.596275007] [mbari_wec_template_cpp]: Subscribing to TFRecord on '/trefoil_data' and '/tf_record'\n[mbari_wec_template_cpp-1] [INFO] [1678127525.596593805] [mbari_wec_template_cpp]: Subscribing to PBRecord on '/powerbuoy_data'\n[mbari_wec_template_cpp-1] [INFO] [1678127525.697067297] [mbari_wec_template_cpp]: /pc_pack_rate_command not available\n[mbari_wec_template_cpp-1] [INFO] [1678127525.797309937] [mbari_wec_template_cpp]: /sc_pack_rate_command not available\n[mbari_wec_template_cpp-1] [INFO] [1678127525.797524439] [mbari_wec_template_cpp]: Found all required services.\n</code></pre></p>"},{"location":"Tutorials/ROS2/CppTemplate/#example","title":"Example","text":"<p>An example using this interface will follow in the next tutorial: Linear Damper Example (C++)</p>"},{"location":"Tutorials/ROS2/MessagesAndServices/","title":"ROS 2 Messages and Services","text":"<p>Working with the simulator as well as the physical buoy can be done through ROS 2 messages and services. There are also API classes for both C++ and Python available.</p> <p>A detailed list of ROS 2 messages and services can be found in ROS 2 Interface-&gt;Interfaces (ROS 2 Messages).</p> <p>Python API class documentation can be found in ROS 2 Interface-&gt;API (Python).</p> <p>C++ API class documentation can be found in ROS 2 Interface-&gt;API (C++).</p>"},{"location":"Tutorials/ROS2/MessagesAndServices/#getting-started-tutorial-series","title":"Getting Started (Tutorial Series)","text":"<p>The following tutorials will help with getting started writing control code for the buoy:</p> <ul> <li>Controller GitHub Template (Python)</li> <li>Controller GitHub Template (C++)</li> </ul>"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/","title":"Quick Start -- Simple Linear Damper Controller (Python)","text":"<p>In this tutorial you will implement a simple linear damper controller for the piston in the WEC Power-Take-Off (PTO). Given motor RPM, it outputs desired motor winding current (interpolated from RPM-&gt;Torque lookup table) to generate a torque to resist piston velocity with a damping force. Configurable gains (scale/retract factor) are applied before output. In the end, you will have a working linear damper controller that is very close to the controller running on both the physical and simulated buoy.</p>"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#prerequisite","title":"Prerequisite","text":"<p>This tutorial assumes you are familiar the steps from the previous tutorial and have built your own custom Python ROS 2 controller package from the mbari_wec_template_py template repository which we will use to implement a simple linear damper controller.</p> <p>To begin, you should have a Python ROS 2 controller package that looks similar to:</p> <pre><code>mbari_wec_linear_damper_py\n\u251c\u2500\u2500 config\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.yaml\n\u251c\u2500\u2500 CONTRIBUTING.md\n\u251c\u2500\u2500 launch\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.launch.py\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 mbari_wec_linear_damper_py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 controller.py\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n\u251c\u2500\u2500 package.xml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 resource\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 mbari_wec_linear_damper_py\n\u251c\u2500\u2500 setup.cfg\n\u251c\u2500\u2500 setup.py\n\u2514\u2500\u2500 test\n    \u251c\u2500\u2500 test_copyright.py\n    \u251c\u2500\u2500 test_flake8.py\n    \u2514\u2500\u2500 test_pep257.py\n</code></pre> <p>with the files modified from the previous tutorial. If you haven't already, follow the steps in the above mentioned link to create a package for this tutorial named <code>mbari_wec_linear_damper_py</code>.</p>"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#linear-damper-controlpolicy","title":"Linear Damper ControlPolicy","text":"<p>A complete example starting from the template may be found here. Line numbers in this tutorial correspond to the lines in relevant files in the full example.</p>"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#parameters","title":"Parameters","text":"<p>Parameters for the controller are:</p> <ul> <li><code>torque_constant</code>: Motor Torque Constant (N-m/Amp)   Constant to convert desired torque to applied motor winding current  </li> <li><code>n_spec</code>: Input Motor Speed (RPM) Breakpoints  (RPM) is the input to the controller and <code>n_spec</code> are the x-components of the breakpoints    for the interpolant, </li> <li><code>torque_spec</code>: Desired Output Motor Torque (N-m) Breakpoints   Torque (N-m) is the eventual desired output of the controller given an input <code>N</code> (motor RPM) and   <code>torque_spec</code> / <code>torque_constant</code> (Amps) are the y-components of the breakpoints for the   interpolant. The controller actually outputs motor winding current (Amps) to generate a torque   in the opposite direction of piston velocity to generate a damping force.</li> </ul> <p>These can be configured using the <code>config/controller.yaml</code> file.</p> config/controller.yaml<pre><code>/linear_damper:\n  ros__parameters:\n    torque_constant: 0.438\n    n_spec: [0.0, 300.0, 600.0, 1000.0, 1700.0, 4400.0, 6790.0]\n    torque_spec: [0.0, 0.0, 0.8, 2.9, 5.6, 9.8, 16.6]\n</code></pre> <p>As you can see, as motor speed increases, so does the damping torque. For low RPM (up to 300), there is no damping.</p> <p>Initialize these variables in <code>ControlPolicy</code> in <code>mbari_wec_linear_damper_py/controller.py</code>. This example makes use of <code>numpy.array</code> as well as <code>scipy.interpolate.interp1d</code>, so don't forget to include those.</p> mbari_wec_linear_damper_py/controller.py<pre><code>import numpy as np\nfrom scipy import interpolate\n\n\nclass ControlPolicy(object):\n    \"\"\"\n    Simple Linear Damper Control Policy.\n    Implements a simple linear damper controller for the piston in the WEC\n    Power-Take-Off (PTO). Given motor RPM, outputs desired motor winding current (interpolated\n    from RPM-&gt;Torque lookup table) to resist piston velocity. Configurable gains\n    (scale/retract factor) are applied before output.\n    \"\"\"\n\n    def __init__(self):\n        # Define any parameter variables here\n        self.Torque_constant = 0.438  # N-m/Amps\n        # Desired damping Torque vs RPM relationship\n        self.N_Spec = np.array([0.0, 300.0, 600.0, 1000.0, 1700.0, 4400.0, 6790.0])  # RPM\n        self.Torque_Spec = np.array([0.0, 0.0, 0.8, 2.9, 5.6, 9.8, 16.6])  # N-m\n</code></pre> <p>Update the dependent variable, <code>I_Spec</code>, and create the interpolator, <code>windcurr_interp1d</code>, which uses <code>interp1d</code> from <code>scipy.interpolate</code>.</p> mbari_wec_linear_damper_py/controller.py<pre><code>    def update_params(self):\n        \"\"\"Update dependent variables after reading in params.\"\"\"\n        # Convert to Motor Winding Current vs RPM and generate interpolator for f(RPM) = I\n        self.I_Spec = self.Torque_Spec / self.Torque_constant  # Amps\n        self.windcurr_interp1d = interpolate.interp1d(self.N_Spec, self.I_Spec,\n                                                      fill_value=self.I_Spec[-1],\n                                                      bounds_error=False)\n</code></pre> <p>Finally, in the <code>Controller</code> class, declare/get/set/update these parameters from ROS 2 (as set in <code>config/controller.yaml</code>).</p> mbari_wec_linear_damper_py/controller.py<pre><code>    def set_params(self):\n        \"\"\"Use ROS2 declare_parameter and get_parameter to set policy params.\"\"\"\n        self.declare_parameter('torque_constant', self.policy.Torque_constant)\n        self.policy.Torque_constant = \\\n            self.get_parameter('torque_constant').get_parameter_value().double_value\n\n        self.declare_parameter('n_spec', self.policy.N_Spec.tolist())\n        self.policy.N_Spec = \\\n            np.array(self.get_parameter('n_spec').get_parameter_value().double_array_value)\n\n        self.declare_parameter('torque_spec', self.policy.Torque_Spec.tolist())\n        self.policy.Torque_Spec = \\\n            np.array(self.get_parameter('torque_spec').get_parameter_value().double_array_value)\n\n        # recompute any dependent variables\n        self.policy.update_params()\n        self.get_logger().info(str(self.policy))\n</code></pre> <p>Add a helper function, <code>__str__</code>, in the <code>ControlPolicy</code> class for this example to report the parameters used.</p> mbari_wec_linear_damper_py/controller.py<pre><code>    def __str__(self):\n        return \"\"\"ControlPolicy:\n\\tTorque_constant: {tc}\n\\tN_Spec: {nspec}\n\\tTorque_Spec: {tspec}\n\\tI_Spec: {ispec}\"\"\".format(tc=self.Torque_constant,\n                            nspec=self.N_Spec,\n                            tspec=self.Torque_Spec,\n                            ispec=self.I_Spec)\n</code></pre>"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#control-policy-target","title":"Control Policy Target","text":"<p>To implement the torque control control policy, we use the <code>target</code> function in <code>ControlPolicy</code>. This is where we accept feedback data and return a command value. In this case, we need the motor <code>rpm</code>, and the gains applied to the winding current damping, <code>scale_factor</code> and <code>retract_factor</code>. Typical values for these gains are</p> <ul> <li>scale_factor = 1</li> <li>retract_factor = 0.6</li> </ul> mbari_wec_linear_damper_py/controller.py<pre><code>    def target(self, rpm, scale_factor, retract_factor):\n        \"\"\"Calculate target value from feedback inputs.\"\"\"\n        N = abs(rpm)\n        I = self.windcurr_interp1d(N)\n\n        # Apply damping gain\n        I *= scale_factor\n\n        # Hysteresis due to gravity / wave assist\n        if rpm &gt; 0.0:\n            I *= -retract_factor\n\n        return float(I)\n</code></pre> <p>So, as you can see we apply a positive damping torque when RPM is negative (piston extending), and a positive damping torque when RPM is positive (piston retracting). The damping torque required is reduced when retracting.</p>"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#controller","title":"Controller","text":"<p>All that is left is to connect the necessary feedback data to the <code>ControlPolicy</code>. In this case, <code>rpm</code>, <code>scale</code>, and <code>retract</code> are present in <code>buoy_interfaces.msg.PCRecord</code> on the <code>/power_data</code> topic published by the Power Controller running on the buoy.</p> <p>To access the data, all that is required is to define the callback <code>def power_callback(self, data)</code> in the <code>Controller</code> class, and pass the data to <code>self.policy.target</code> to get the desired winding current command. Various commands are available, and this time we will be using <code>self.send_pc_wind_curr_command(wind_curr, blocking=False)</code></p> mbari_wec_linear_damper_py/controller.py<pre><code>    def power_callback(self, data):\n        \"\"\"Provide feedback of '/power_data' topic from Power Controller.\"\"\"\n        # Update class variables, get control policy target, send commands, etc.\n        wind_curr = self.policy.target(data.rpm, data.scale, data.retract)\n\n        self.get_logger().info('WindingCurrent:' +\n                               f' f({data.rpm:.02f}, {data.scale:.02f}, {data.retract:.02f})' +\n                               f' = {wind_curr:.02f}')\n\n        self.send_pc_wind_curr_command(wind_curr, blocking=False)\n</code></pre> <p>Finally, let's set the Power Controller's publish rate to the maximum of 50Hz. Uncomment the line to set the PC Pack Rate in <code>Controller.__init__</code>:</p> mbari_wec_linear_damper_py/controller.py<pre><code>    def __init__(self):\n        super().__init__('linear_damper')\n\n        self.policy = ControlPolicy()\n        self.set_params()\n\n        # set packet rates from controllers here\n        # controller defaults to publishing feedback @ 10Hz\n        # call these to set rate to 50Hz or provide argument for specific rate\n        self.set_pc_pack_rate(blocking=False)  # set PC feedback publish rate to 50Hz\n</code></pre> <p>In this tutorial, we've named this controller <code>linear_damper</code>. Don't forget to update controller names along with other changes according to the previous tutorial.</p>"},{"location":"Tutorials/ROS2/PythonLinearDamperExample/#try-it-out","title":"Try It Out","text":"<p>Make sure to build and source your workspace. This tutorial assumes you cloned your package to <code>~/controller_ws/src</code> and you have sourced <code>mbari_wec_gz</code> and <code>mbari_wec_utils</code> <pre><code>$ cd ~/controller_ws\n$ colcon build\n$ source install/local_setup.bash\n</code></pre></p> <p>We will be using <code>ros2 launch</code> and <code>launch/controller.launch.py</code> to run our new controller.</p> <p>To run the controller along with the simulation, launch your controller: <code>$ ros2 launch mbari_wec_linear_damper_cpp controller.launch.py</code></p> <p>Then, in another terminal (with <code>mbari_wec_gz</code> sourced), launch the sim: <code>$ ros2 launch buoy_gazebo mbari_wec.launch.py</code> and click the play button.</p> <p>You should see output similar to:</p> <pre><code>[linear_damper-1] [INFO] [1677864397.617058507] [linear_damper]: Found all required services.\n[linear_damper-1] [INFO] [1677864397.618426488] [linear_damper]: ControlPolicy:\n[linear_damper-1]       Torque_constant: 0.438\n[linear_damper-1]       N_Spec: [   0.  300.  600. 1000. 1700. 4400. 6790.]\n[linear_damper-1]       Torque_Spec: [ 0.   0.   0.8  2.9  5.6  9.8 16.6]\n[linear_damper-1]       I_Spec: [ 0.          0.          1.82648402  6.62100457 12.78538813 22.37442922\n[linear_damper-1]  37.89954338]\n[linear_damper-1] [INFO] [1677864197.432679525] [linear_damper]: WindingCurrent: f(4962.91, 1.00, 0.60) = -15.62\n[linear_damper-1] [INFO] [1677864197.532727531] [linear_damper]: WindingCurrent: f(7764.73, 1.00, 0.60) = -22.74\n[linear_damper-1] [INFO] [1677864197.632748699] [linear_damper]: WindingCurrent: f(10504.88, 1.00, 0.60) = -22.74\n[linear_damper-1] [INFO] [1677864197.732851121] [linear_damper]: WindingCurrent: f(11491.33, 1.00, 0.60) = -22.74\n[linear_damper-1] [INFO] [1677864197.833078440] [linear_damper]: WindingCurrent: f(11075.84, 1.00, 0.60) = -22.74\n[linear_damper-1] [INFO] [1677864197.933050356] [linear_damper]: WindingCurrent: f(9546.51, 1.00, 0.60) = -22.74\n[linear_damper-1] [INFO] [1677864198.033185882] [linear_damper]: WindingCurrent: f(7499.68, 1.00, 0.60) = -22.74\n[linear_damper-1] [INFO] [1677864198.133197926] [linear_damper]: WindingCurrent: f(5190.35, 1.00, 0.60) = -16.51\n[linear_damper-1] [INFO] [1677864198.233322713] [linear_damper]: WindingCurrent: f(2353.02, 1.00, 0.60) = -9.06\n[linear_damper-1] [INFO] [1677864198.333507127] [linear_damper]: WindingCurrent: f(-257.59, 1.00, 0.60) = 0.00\n[linear_damper-1] [INFO] [1677864198.433489830] [linear_damper]: WindingCurrent: f(-2185.58, 1.00, 0.60) = 14.51\n[linear_damper-1] [INFO] [1677864198.533538450] [linear_damper]: WindingCurrent: f(-2987.98, 1.00, 0.60) = 17.36\n[linear_damper-1] [INFO] [1677864198.633671249] [linear_damper]: WindingCurrent: f(-3513.15, 1.00, 0.60) = 19.22\n[linear_damper-1] [INFO] [1677864198.733703803] [linear_damper]: WindingCurrent: f(-3738.12, 1.00, 0.60) = 20.02\n[linear_damper-1] [INFO] [1677864198.833889518] [linear_damper]: WindingCurrent: f(-3751.64, 1.00, 0.60) = 20.07\n[linear_damper-1] [INFO] [1677864198.933993414] [linear_damper]: WindingCurrent: f(-3595.71, 1.00, 0.60) = 19.52\n[linear_damper-1] [INFO] [1677864199.034078009] [linear_damper]: WindingCurrent: f(-3306.87, 1.00, 0.60) = 18.49\n[linear_damper-1] [INFO] [1677864199.134273438] [linear_damper]: WindingCurrent: f(-3012.52, 1.00, 0.60) = 17.45\n[linear_damper-1] [INFO] [1677864199.234371669] [linear_damper]: WindingCurrent: f(-2617.97, 1.00, 0.60) = 16.05\n[linear_damper-1] [INFO] [1677864199.334275962] [linear_damper]: WindingCurrent: f(-2269.58, 1.00, 0.60) = 14.81\n[linear_damper-1] [INFO] [1677864199.434369620] [linear_damper]: WindingCurrent: f(-1893.56, 1.00, 0.60) = 13.47\n[linear_damper-1] [INFO] [1677864199.534461914] [linear_damper]: WindingCurrent: f(-1513.34, 1.00, 0.60) = 11.14\n[linear_damper-1] [INFO] [1677864199.634556815] [linear_damper]: WindingCurrent: f(-1128.46, 1.00, 0.60) = 7.75\n[linear_damper-1] [INFO] [1677864199.734798736] [linear_damper]: WindingCurrent: f(-825.91, 1.00, 0.60) = 4.53\n[linear_damper-1] [INFO] [1677864199.834753871] [linear_damper]: WindingCurrent: f(-586.78, 1.00, 0.60) = 1.75\n[linear_damper-1] [INFO] [1677864199.934809041] [linear_damper]: WindingCurrent: f(-393.25, 1.00, 0.60) = 0.57\n[linear_damper-1] [INFO] [1677864200.035109715] [linear_damper]: WindingCurrent: f(-132.04, 1.00, 0.60) = 0.00\n[linear_damper-1] [INFO] [1677864200.134981992] [linear_damper]: WindingCurrent: f(92.19, 1.00, 0.60) = -0.00\n[linear_damper-1] [INFO] [1677864200.235094219] [linear_damper]: WindingCurrent: f(338.10, 1.00, 0.60) = -0.14\n[linear_damper-1] [INFO] [1677864200.335164181] [linear_damper]: WindingCurrent: f(636.96, 1.00, 0.60) = -1.36\n[linear_damper-1] [INFO] [1677864200.435227880] [linear_damper]: WindingCurrent: f(863.33, 1.00, 0.60) = -2.99\n</code></pre>"},{"location":"Tutorials/ROS2/PythonOpenLoopControl/","title":"Open-Loop Force Command Example (Python)","text":""},{"location":"Tutorials/ROS2/PythonTemplate/","title":"Quick Start \u2014 Writing External Controller With GitHub Template Repository","text":"<p>In this tutorial, you will make and customize a GitHub repository from a GitHub Template with a ROS 2 Python package and code ready to implement your own external controller utilizing the <code>buoy_api_py</code> interface. This interface may be used with the both the simulated and physical buoy.</p>"},{"location":"Tutorials/ROS2/PythonTemplate/#interfaces-and-templates","title":"Interfaces and Templates","text":"<p>There are two GitHub template repositories set up (C++/Python) for a quick start on writing a custom controller utilizing buoy_api_cpp and buoy_api_py. Please see C++ examples and Python examples for example controller implementations.</p> <ul> <li>mbari_wec_template_cpp</li> <li>mbari_wec_template_py</li> </ul>"},{"location":"Tutorials/ROS2/PythonTemplate/#using-python-template","title":"Using Python Template","text":""},{"location":"Tutorials/ROS2/PythonTemplate/#creating-your-own-repo-from-the-template","title":"Creating your own repo from the template","text":"<p>You may also refer to GitHub's template documentation</p> <p>To start using the Python GitHub template</p> <ol> <li> <p>Navigate to mbari_wec_template_py and click the green button with the text <code>Use this template</code> and select <code>Create a new repository</code></p> <p></p> </li> <li> <p>Next, set up the repository like you would any new GitHub repository choosing the owner, repository name, public/private, etc.</p> </li> <li>Make a ROS 2 workspace    <pre><code>$ mkdir -p ~/controller_ws/src\n$ cd ~/controller_ws/src\n</code></pre></li> <li>Now that your new repository is set up, clone it to your local machine, make a branch, etc. <pre><code>$ git clone https://github.com/&lt;owner&gt;/&lt;repo_name&gt;.git\n$ cd ~/controller_ws\n</code></pre></li> </ol> <p>You should now have a Python ROS 2 package with the following structure:</p> <pre><code>&lt;repo_name&gt;\n    \u251c\u2500\u2500 config\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.yaml\n    \u251c\u2500\u2500 launch\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.launch.py\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 mbari_wec_template_py\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 controller.py\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 package.xml\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 resource\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 mbari_wec_template_py\n    \u251c\u2500\u2500 setup.cfg\n    \u251c\u2500\u2500 setup.py\n    \u2514\u2500\u2500 test\n        \u251c\u2500\u2500 test_copyright.py\n        \u251c\u2500\u2500 test_flake8.py\n        \u2514\u2500\u2500 test_pep257.py\n</code></pre>"},{"location":"Tutorials/ROS2/PythonTemplate/#customizing-the-controller","title":"Customizing the controller","text":"<p>You may also refer to the <code>README.md</code> in your newly cloned repository.</p>"},{"location":"Tutorials/ROS2/PythonTemplate/#modify-template-for-your-package","title":"Modify template for your package","text":"<p>Replace <code>mbari_wec_template_py</code> with your package name and modify other fields as necessary in:</p> <ul> <li>package.xml (lines 4-8)</li> </ul> package.xml<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\" schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n  &lt;name&gt;repo_name&lt;/name&gt;  &lt;!-- Update package name --&gt;\n  &lt;version&gt;3.14&lt;/version&gt;  &lt;!-- Update version --&gt;\n  &lt;description&gt;Your Controller Description&lt;/description&gt;  &lt;!-- Update description --&gt;\n  &lt;maintainer email=\"your@email\"&gt;Your Name&lt;/maintainer&gt;  &lt;!-- Update email and name --&gt;\n  &lt;license&gt;Your License&lt;/license&gt;  &lt;!-- Update license --&gt;\n</code></pre> <ul> <li>setup.py (lines 7, 11, 22-25, 29)</li> </ul> setup.py<pre><code>package_name = 'your_package_name'  # Update package name\n\nsetup(\n    name=package_name,\n    version='3.14',  # Update version\n    packages=[f'{package_name}'],\n    data_files=[\n        ('share/ament_index/resource_index/packages',\n            ['resource/' + package_name]),\n        ('share/' + package_name, ['package.xml']),\n        (os.path.join('share', package_name, 'launch'), glob('launch/*.launch.py')),\n        (os.path.join('share', package_name, 'config'), glob('config/*.yaml'))\n    ],\n    install_requires=['setuptools'],\n    zip_safe=True,\n    maintainer='Your Name',  # Update name\n    maintainer_email='your@email',  # Update email\n    description='Your package description',  # Update package description\n    license='Your License',  # Update license\n    tests_require=['pytest'],\n    entry_points={\n        'console_scripts': [\n            f'your_controller_name = {package_name}.controller:main',  # Update controller executable name\n</code></pre> <ul> <li>setup.cfg (lines 2, 4)     Update script_dir and install_scripts locations with your package name</li> </ul> setup.cfg<pre><code>[develop]\nscript_dir=$base/lib/your_package_name\n[install]\ninstall_scripts=$base/lib/your_package_name\n</code></pre> <ul> <li>launch/controller.launch.py (lines 22, 35-36)</li> </ul> launch/controller.launch.py<pre><code>package_name = 'your_package_name'   # Update package name\n\n\ndef generate_launch_description():\n    ld = LaunchDescription()\n    config = os.path.join(\n        get_package_share_directory(package_name),\n        'config',\n        'controller.yaml'\n        )\n\n    node = Node(\n        package=package_name,\n        name='your_controller_name',  # Update controller name (same as name in config.yaml)\n        executable='your_controller_name',  # Update controller executable name from setup.py\n</code></pre> <ul> <li>config/controller.yaml (line 1)     Update first line with your controller name (same as node name in launch file)</li> </ul> config/controller.yaml<pre><code>/your_controller_name:\n  ros__parameters:\n    foo: 1.0\n</code></pre> <p>and rename two files/folders</p> <ul> <li>the empty file <code>resource/mbari_wec_template_py</code></li> <li>the Python package <code>mbari_wec_template_py</code> containing <code>controller.py</code></li> </ul> <p>resulting in the following folder structure:</p> <pre><code>repo_name\n    \u251c\u2500\u2500 config\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.yaml\n    \u251c\u2500\u2500 launch\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 controller.launch.py\n    \u251c\u2500\u2500 LICENSE\n    \u251c\u2500\u2500 your_package_name\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 controller.py\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n    \u251c\u2500\u2500 package.xml\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 resource\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 your_package_name\n    \u251c\u2500\u2500 setup.cfg\n    \u251c\u2500\u2500 setup.py\n    \u2514\u2500\u2500 test\n        \u251c\u2500\u2500 test_copyright.py\n        \u251c\u2500\u2500 test_flake8.py\n        \u2514\u2500\u2500 test_pep257.py\n</code></pre> <p>Modify <code>setup.py</code> as desired and add any dependencies in <code>package.xml</code> following standard ROS 2 documentation.</p>"},{"location":"Tutorials/ROS2/PythonTemplate/#implement-controller","title":"Implement Controller","text":"<p>Assuming you have followed the above and renamed the Python package <code>mbari_wec_template_py</code> to your package name, <code>&lt;your_package_name&gt;/controller.py</code> is stubbed out to implement your custom external controller. You may also use <code>config/controller.yaml</code> for any policy parameters.</p>"},{"location":"Tutorials/ROS2/PythonTemplate/#controlpolicy","title":"ControlPolicy","text":"<p>You may use the class <code>ControlPolicy</code> in <code>&lt;your_package_name&gt;/controller.py</code> to implement your controller.</p> <pre><code>class ControlPolicy(object):\n\n    def __init__(self):\n        # Define any parameter variables here\n        self.foo = 1.0\n\n        self.update_params()\n\n    def update_params(self):\n        \"\"\"Update dependent variables after reading in params.\"\"\"\n        self.bar = 10.0 * self.foo\n\n        pass  # remove if there's anything to set above\n\n    # Modify function inputs as desired\n    def target(self, *args, **kwargs):\n        \"\"\"Calculate target value from feedback inputs.\"\"\"\n\n        # secret sauce\n\n        return 0.0  # obviously, modify to return proper target value\n</code></pre> <ul> <li>Set any configurable parameters in <code>__init__</code> on line 23</li> </ul> <pre><code>    def __init__(self):\n        # Define any parameter variables here\n        self.foo = 1.0\n\n        self.update_params()\n</code></pre> <ul> <li>Set any dependent variables in <code>update_params</code> on line 29</li> </ul> <pre><code>    def update_params(self):\n        \"\"\"Update dependent variables after reading in params.\"\"\"\n        self.bar = 10.0 * self.foo\n\n        pass  # remove if there's anything to set above\n</code></pre> <ul> <li>Declare/get/update params in the <code>set_params</code> function of the <code>Controller</code> class on line 118</li> </ul> <pre><code>    def set_params(self):\n        \"\"\"Use ROS2 declare_parameter and get_parameter to set policy params.\"\"\"\n        self.declare_parameter('foo', self.policy.foo)\n        self.policy.foo = \\\n            self.get_parameter('foo').get_parameter_value().double_value\n\n        # recompute any dependent variables\n        self.policy.update_params()\n</code></pre> <ul> <li>Then, your control logic will go in the <code>target</code> function on line 36.     Modify the input args as well as the return value as necessary</li> </ul> <pre><code>    # Modify function inputs as desired\n    def target(self, *args, **kwargs):  # noqa: D202\n        \"\"\"Calculate target value from feedback inputs.\"\"\"\n\n        # secret sauce\n\n        return 0.0  # obviously, modify to return proper target value\n</code></pre>"},{"location":"Tutorials/ROS2/PythonTemplate/#controller","title":"Controller","text":"<p>The <code>Controller</code> class contains an instance of <code>ControlPolicy</code> as the member variable, <code>self.policy</code>. The <code>self.policy.target</code> function may be called anywhere within the <code>Controller</code> class. You may call it inside any of the data callbacks to enable feedback control (for example):</p> <pre><code>    # To subscribe to any topic, simply define the specific callback, e.g. power_callback\n    def power_callback(self, data):\n        '''Callback for '/power_data' topic from Power Controller'''\n        # get target value from control policy\n        target_value = self.policy.target(data.rpm, data.scale, data.retract)\n\n        # send a command, e.g. winding current\n        self.send_pc_wind_curr_command(target_value, blocking=False)\n</code></pre> <p>Or, set up a loop in <code>main()</code> and run open-loop:</p> <pre><code>def main():\n    rclpy.init()\n    controller = Controller()\n    rate = controller.create_rate(50.0)  # Hz\n    while rclpy.ok():\n\n        # Open-loop control logic\n\n        rclpy.spin_once(controller)\n        rate.sleep()\n    rclpy.shutdown()\n</code></pre> <p>You may get feedback data from any of the buoy topics by simply creating a specific callback listed below. For feedback data you'd like to use in another area of the class, feel free to assign them to class variables.</p> <p>(Delete any callbacks you don't need in the <code>Controller</code> class)</p> <p>Available callback functions:</p> <p><code>/ahrs_data</code> \u2192 <code>def ahrs_callback(self, data):</code> <code>/battery_data</code> \u2192 <code>def battery_callback(self, data):</code> <code>/spring_data</code> \u2192 <code>def spring_callback(self, data):</code> <code>/power_data</code> \u2192 <code>def power_callback(self, data):</code> <code>/trefoil_data</code> \u2192 <code>def trefoil_callback(self, data):</code> <code>/powerbuoy_data</code> \u2192 <code>def powerbuoy_callback(self, data):</code> </p> <p>You may also send commands from within the <code>Controller</code> class:</p> <p><code>self.send_pump_command(duration_mins, blocking=False)</code> <code>self.send_valve_command(duration_sec, blocking=False)</code> <code>self.send_pc_wind_curr_command(wind_curr_amps, blocking=False)</code> <code>self.send_pc_bias_curr_command(bias_curr_amps, blocking=False)</code> <code>self.send_pc_scale_command(scale_factor, blocking=False)</code> <code>self.send_pc_retract_command(retract_factor, blocking=False)</code> </p> <p>In the <code>Controller</code> constructor, you may also uncomment lines 55 or 56 to set the publish rates for the Spring or Power Controllers on the buoy. These controllers default to publishing at 10Hz. You can call commands to set the rates anywhere from 10Hz to 50Hz (default argument is 50Hz).</p> <pre><code>    def __init__(self):\n        super().__init__('controller')\n\n        self.policy = ControlPolicy()\n        self.set_params()\n\n        # set packet rates from controllers here\n        # controller defaults to publishing @ 10Hz\n        # call these to set rate to 50Hz or provide argument for specific rate\n        # self.set_pc_pack_rate(blocking=False)  # set PC publish rate to 50Hz\n        # self.set_sc_pack_rate(blocking=False)  # set SC publish rate to 50Hz\n</code></pre> <p>The <code>Controller</code> is also capable of synchronizing its clock from the sim <code>/clock</code> by uncommenting line 61. Since the <code>Controller</code> inherits from <code>rclpy.Node</code>, you may use <code>self.get_clock()</code> and other various time-related functions of <code>rclpy.Node</code>.</p> <pre><code>        # Use this to set node clock to use sim time from /clock (from gazebo sim time)\n        # Access node clock via self.get_clock() or other various\n        # time-related functions of rclpy.Node\n        # self.use_sim_time()\n</code></pre>"},{"location":"Tutorials/ROS2/PythonTemplate/#build-test-run","title":"Build, Test, Run","text":"<p>At this point, your new package should build, pass tests, and run against the sim (will connect but do nothing).</p> <p>It is assumed that you have already installed or built the buoy packages.</p> <p>From your workspace (e.g. <code>~/controller_ws</code>) build your package: <pre><code>$ colcon build\nStarting &gt;&gt;&gt; mbari_wec_template_py\n--- stderr: mbari_wec_template_py\n/usr/lib/python3/dist-packages/setuptools/command/install.py:34: SetuptoolsDeprecationWarning: setup.py install is deprecated. Use build and pip and other standards-based tools.\n  warnings.warn(\n---\nFinished &lt;&lt;&lt; mbari_wec_template_py [0.74s]\n\nSummary: 1 package finished [0.89s]\n  1 package had stderr output: mbari_wec_template_py\n</code></pre> You may also build only your new controller package (if you have other packages in the workspace) using: <code>$ colcon build --packages-up-to &lt;your_package_name&gt;</code></p> <p>Then, source and test: <pre><code>$ source install/local_setup.bash\n$ colcon test\nStarting &gt;&gt;&gt; mbari_wec_template_py\n--- stderr: mbari_wec_template_py\n\n=============================== warnings summary ===============================\ntest/test_flake8.py::test_flake8\ntest/test_flake8.py::test_flake8\n  Warning: SelectableGroups dict interface is deprecated. Use select.\n\n-- Docs: https://docs.pytest.org/en/stable/warnings.html\n---\nFinished &lt;&lt;&lt; mbari_wec_template_py [0.74s]\n\nSummary: 1 package finished [0.87s]\n  1 package had stderr output: mbari_wec_template_py\n</code></pre> Or, you may test only your new controller package using: <code>$ colcon test --packages-select &lt;your_package_name&gt;</code></p> <p>Next, in another terminal run the sim (after sourcing the sim packages of course): <code>$ ros2 launch buoy_gazebo mbari_wec.launch.py</code></p> <p>Now, in the previous terminal, launch the empty controller: <pre><code>$ ros2 launch &lt;your_package_name&gt; controller.launch.py\n</code></pre></p> <p>And you should see something similar to: <pre><code>[INFO] [launch]: Default logging verbosity is set to INFO\n[INFO] [controller-1]: process started with pid [1409887]\n[controller-1] [INFO] [1678130539.867493131] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._xb_record.XBRecord'&gt; on '/ahrs_data'\n[controller-1] [INFO] [1678130540.031500810] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._bc_record.BCRecord'&gt; on '/battery_data'\n[controller-1] [INFO] [1678130540.031972332] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._sc_record.SCRecord'&gt; on '/spring_data'\n[controller-1] [INFO] [1678130540.032390456] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._pc_record.PCRecord'&gt; on '/power_data'\n[controller-1] [INFO] [1678130540.032810815] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._tf_record.TFRecord'&gt; on '/trefoil_data'\n[controller-1] [INFO] [1678130540.033268687] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._xb_record.XBRecord'&gt; on '/xb_record'\n[controller-1] [INFO] [1678130540.033703510] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._bc_record.BCRecord'&gt; on '/bc_record'\n[controller-1] [INFO] [1678130540.034091374] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._sc_record.SCRecord'&gt; on '/sc_record'\n[controller-1] [INFO] [1678130540.034467140] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._pc_record.PCRecord'&gt; on '/pc_record'\n[controller-1] [INFO] [1678130540.034868686] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._tf_record.TFRecord'&gt; on '/tf_record'\n[controller-1] [INFO] [1678130540.035298496] [controller]: Subscribing to &lt;class 'buoy_interfaces.msg._pb_record.PBRecord'&gt; on '/powerbuoy_data'\n[controller-1] [INFO] [1678130540.286577653] [controller]: /pc_pack_rate_command not available\n[controller-1] [INFO] [1678130540.537643441] [controller]: /sc_pack_rate_command not available\n[controller-1] [INFO] [1678130540.538230613] [controller]: Found all required services.\n</code></pre></p>"},{"location":"Tutorials/ROS2/PythonTemplate/#example","title":"Example","text":"<p>An example using this interface will follow in the next tutorial: Linear Damper Example (Python)</p>"},{"location":"Tutorials/Simulation/RunSimulator/","title":"Running the Simulator","text":""},{"location":"Tutorials/Simulation/RunSimulator/#introduction","title":"Introduction","text":"<p>This tutorial will illustrate how to start the buoy simulation in Gazebo, when the simulation is running, a rendering of the buoy system motions will be visible, and ROS2 messages will be published that represent the buoy systems state.  The simulation also provides the same ROS2 services the real buoy does, so will respond to ROS2 messages appropriately.</p> <p>Subsequent tutorials will illustrate how to view and plot data being published by the simulation, view data logs being generated, and control the simulated buoy with the command-line tool that is available on the buoy.</p>"},{"location":"Tutorials/Simulation/RunSimulator/#how-to-run","title":"How to Run","text":"<p>To run the simulator, it is necessary to source the workspace in a separate terminal than was used to build the application.  Therefore, open a new terminal window and do the following:</p> <ol> <li>Source the workspace <pre><code>$ . ~/mbari_wec_ws/install/setup.bash\n</code></pre></li> <li>Launch the simulation <pre><code>$ ros2 launch buoy_gazebo mbari_wec.launch.py \n</code></pre></li> </ol> <p>The Gazebo rendering of the buoy system should become visible and appear as follows:</p> <p></p> <p>To start the simulation, press the \"play\" arrow in the lower left, the buoy should start to move in response to incoming waves.</p> <p>It is also possible to adjust various parameters such as the sea-state, visibility of the rendering, and speed the simulation will run relative to real-time.  These topics are covered in a later tutorial.</p> <p>To view the ROS2 messages and associated data while the simulation runs, proceed to the next tutorial: View ROS2 Messages</p>"},{"location":"Tutorials/Simulation/RunSimulator/#notes-on-workspaces","title":"Notes on Workspaces","text":"<p>The step of sourcing the workspace is important and must be done in every window that the simulation and associated tools are accessed from.  It is possible, and possibly convenient, to put the source command from step 1 above in the .bashrc or similar place if a different shell is being used.  This will automatically perform this step anytime a new window is opened.  Beware however, the software can not be built from source in a window where this workspace has previously been sourced.  So when re-compiling the source often it can be problematic to have this line in .bashrc.  When primarily running the simulations without frequent re-building of the software, it is then appropriate to use .bashrc in this way, just remember to take it out before opening a window where you want to do a \"colcon build\".</p>"},{"location":"Tutorials/Simulation/SimulatorInteractionPbcmd/","title":"Run-Time Control using pbcmd","text":""},{"location":"Tutorials/Simulation/SimulatorInteractionPbcmd/#introduction","title":"Introduction","text":"<p>There is a command interpreter running on the physical buoy that provides some control over the behavior of the buoy while it is deployed.  This is a Linux executable that implements a number of commands, accepts appropriate arguments, and issues commands over the CANbus or ROS 2 on the buoy to effect a change of buoy behavior.  These commands can also be issued programmatically as described in subsequent tutorials, but pbcmd is the human interface.  </p> <p>This same command and interface is implemented in the simulation environment, so it is possible to change the behavior of the simulated buoy from the command line in the same way as can be done on the physical buoy.  However many of the possible commands are not sensible in the simulated environment, so are not implemented, but instead return a message indicating they aren't relevant in simulation.  A key example is the command to open and close the heave-cone doors, because the simulator can not change this behavior while running, the command to do so is inactive.  Similarly, it makes no sense to turn on and off the electrical ground fault detector that exists on the buoy, but does not exist in simulation.</p>"},{"location":"Tutorials/Simulation/SimulatorInteractionPbcmd/#pbcmd-usage","title":"pbcmd Usage","text":"<p>Issuing 'pbcmd' at the command prompt provides guidance on the possible commands.  In simulation it also indicates which commands are supported in simulation, on the at-sea system, all commands have an effect.  </p> <p>First source the workspace as usual: <pre><code>$ cd /path/to/workspace\n$ source install/setup.bash\n</code></pre></p> <p>Then, run <code>pbcmd</code> or any of the commands listed in its output:</p> <pre><code>$ pbcmd\n\npbcmd: Multi-call command Power Buoy dispatcher\nCommands currently supported in Simulation:\n*               pump  - Spring Controller pump  off or on for a time in minutes &lt;= 10\n*              valve  - Spring Controller valve off or on for a time in seconds &lt;= 12\n*       sc_pack_rate  - Set the CANBUS packet rate from the spring controller\n*           pc_Scale  - Set the scale factor\n*         pc_Retract  - Set the retract factor\n*        pc_WindCurr  - Set the winding current target\n*        pc_BiasCurr  - Set the winding current bias\n*        pc_PackRate  - Set the CANBUS packet rate\n\nCommands currently not supported in Simulation:\n*             bender  - Sets the state of the bender module\n*      reset_battery  - Reset battery controller (caution - no args)\n\n*             tether  - Spring Controller tether power on or off\n*       reset_spring  - Reset Spring Controller (caution - no args)\n\n*        pc_VTargMax  - Set the max target voltage\n*   pc_ChargeCurrLim  - Set the maximum battery charge current\n*     pc_DrawCurrLim  - Set the maximum battery current draw\n*      pc_BattSwitch  - Set the battery switch state\n*            pc_Gain  - Set the gain scheduler gain\n*      pc_StdDevTarg  - Set the target RPM standard deviation\n\n*          tf_SetPos  - Open/close the doors in the heave-cone\n*    tf_SetActualPos  - Open/close the doors in the heave-cone\n*         tf_SetMode  - Set controller mode\n*   tf_SetChargeMode  - Set Battery Charge mode\n* tf_SetStateMachine  - Set Battery Charge mode\n*      tf_SetCurrLim  - Set controller current limit\n*        tf_WatchDog  - Toggle controller watchdog (caution - no args)\n*           tf_Reset  - Reset Controller (caution - no args)\n\n\nFor help on a command use the command name, i.e. \"bender\";\n\nExcept the reset commands which take no arguments.\n\nDO NOT enter reset_battery and expect to get help. The command will execute!\n</code></pre> <p>Note that at the end of this usage message, there is a hint that typing most commands without an argument will supply some further help.</p>"},{"location":"Tutorials/Simulation/SimulatorInteractionPbcmd/#command-descriptions","title":"Command descriptions","text":"<ul> <li> <p>pump - This command turns on and off the gas pump that pumps Nitrogen from the upper pneumatic spring chamber to the lower spring chamber.  The result of this is the mean position of the position will slowly rise.  The rate is about 1 inch per minute of pump action, a required argument for this command specifies how long the pump will run for, in minutes, and must be between 0 and 10.  After this timeout the pump will stop even if no further commands are issued.  A \"pump 0\" command stops the pump immediately.</p> </li> <li> <p>valve - The valve command releases Nitrogen gas from the lower chamber to the upper chamber, resulting in the mean position of the piston lowering.  This process is much faster so the required argument for this command is in seconds, and must be between 0 and 10.  After this timeout the valve closes even if no further commands are issued.  A \"valve 0\" command closes the pump immediately.</p> </li> <li> <p>sc_pack_rate - This command sets the data packet rate for data coming from the spring controller, the required argument between 10 and 50 indicates the desired data rate in Hz.  This controls the rate of the ROS 2 messages from the spring controller on the buoy, and in the simulator.</p> </li> <li> <p>pc_scale - This command adjusts the multiplier that is applied to the default motor-current/RPM relationship that is programmed into the power converter.  This value can be from 0.4 to 1.5, allowing a range of damping to be applied.</p> </li> <li> <p>pc_Retract - This command adjusts an additional multiplier that is applied to the default motor-current/RPM relationship during piston retraction.  This value can be from 0.4 to 1.0, and allows the damping behavior of the system to be asymmetrical, promoting retraction since the pneumatic spring can not pull as hard as the waves can.</p> </li> <li> <p>pc_WindCurr - This command directly sets the winding current in the electric motor and accepts a value between -35 Amps and +35 Amps.  This value is the quadrature current in the permanent magnet electric motor, and therefore corresponds directly with applied torque. A positive winding current produces a torque that applies a force that retracts the piston. The controller applies this specified torque for two seconds.  After that time, if no new pc_WindCurr command is executed, the system returns to following the default motor-current/RPM relationship (adjusted by the Scale and Retract factor as described).  This allows safety in the case of a communication failure, and makes it a bit impractical to manipulate the winding current manually from the keyboard. As described in subsequent tutorials, programmatically adjusting this value in response to the behavior of the wave-energy converter is the primary automated external control mechanism.</p> </li> <li> <p>pc_BiasCurr - This command applies an offset to the default motor-current/RPM relationship. This value can be between -15 Amps and +15 Amps and is applied for 10 seconds before the system reverts to the default motor-current/RPM relationship.  A positive current corresponds to a torque that tends to retract the piston.  This command is useful for temporarily changing the equilibrium point of the piston at sea.</p> </li> <li> <p>pc_pack_rate - This command sets the data packet rate for data coming from the power converter, the required argument between 10 and 50 indicates the desired data rate in Hz.  This controls the rate of the ROS 2 messages from the power converter on the buoy, and in the simulator.</p> </li> </ul>"},{"location":"Tutorials/Simulation/SimulatorInteractionPbcmd/#example-usage","title":"Example Usage","text":"<p>As an example, issue the following commands in a terminal where the workspace has been sourced:</p> <ol> <li> <p>Launch the simulation without incident waves by issuing the following commands, the first command over-rides the default sea-state and results in no incident wave-forcing on the buoy when the \"regenerate_models\" flag is set to false: <pre><code>$ empy -D 'inc_wave_spectrum_type=\"None\"' -o ~/mbari_wec_ws/install/buoy_description/share/buoy_description/models/mbari_wec/model.sdf ~/mbari_wec_ws/install/buoy_description/share/buoy_description/models/mbari_wec/model.sdf.em\n\n$ ros2 launch buoy_gazebo mbari_wec.launch.py regenerate_models:=false\n</code></pre></p> </li> <li> <p>Start the simulation in the GUI by pressing the play button.</p> </li> <li> <p>Start PlotJuggler <pre><code>$ ros2 run plotjuggler plotjuggler &amp;\n</code></pre></p> </li> <li> <p>Select messages wcurrent and rpm from the /power_data topic and the range_finder message from the /spring_data topic, and then create plots to display these messages in separate windows.</p> </li> <li> <p>Issue the following command to introduce a 10A winding current offset in the motor-current/RPM relationship.</p> </li> </ol> <pre><code>$ pc_BiasCurr 10\n</code></pre> <ul> <li> <p>After 20 seconds of simulation time or so, the plotjuggler window should look approximately as below.  One can see that the command resulted in an additional 10 Amps of motor winding current being present (time = 6 seconds in plot), this additional torque spins the motor and a force is applied to retract the piston, which is evident in the range_finder data.  </p> </li> <li> <p>After a 10 second timeout, because no new current over-ride command is issued, the system reverts to the default motor-current/RPM relationship that doesn't include the offset (time = 16 seconds in plot).  After this extra torque is removed, the weight of the heave cone causes the piston to extend back to it's nominal mean position causing the motor to spin in the opposite direction (time = 16-20 seconds in the plot). The default motor-current/RPM relationship is programmed to resist this motion and a smaller positive motor-current is applied during this time.  </p> </li> <li> <p>After time = 21 seconds, the energy of the raised heave-cone has been dissipated into the PTO system and the system comes mostly to rest.  The slow creep of the piston beyond 21 seconds is due to the heating effects of the pneumatic spring, heat has been created in the gas spring which slowly dissipates to the environment and the lower spring pressure drops slowly and lowers the piston gradually.</p> </li> </ul> <p></p>"},{"location":"Tutorials/Simulation/SimulatorInteractionPbcmd/#exercises","title":"Exercises","text":"<p>To extend the previous example, some interesting exercises to try are the following:</p> <ul> <li> <p>Repeat the above example but also plot the battery voltage and current.  Observe how current flows from the battery to raise the piston and heave cone when the pc_BiasCurr 10 command is issued, and then when the timeout occurs, the potential energy of the raised heave cone is converted to electrical energy and current flows into the battery, with a commensurate change in battery voltage.</p> </li> <li> <p>Plot the upper and lower spring pressures, observer how they change relative to piston position, and their decay in time after the piston comes to rest.</p> </li> <li> <p>Repeatedly issue the \"pc_BiasCurr 10\" command before the timeout expires, note how the timeout is extended to 10 seconds beyond the last command issued.</p> </li> <li> <p>Issue a \"pc_WindCurr 10\" command instead of the pc_BiasCurr command.  This command directly sets the winding current, so the resulting winding current is not affected by the motor RPM until after the timeout has expired.  For this command, the timeout is two seconds.</p> </li> <li> <p>Plot other messages while manipulating the winding current.  Note how the buoy and heave-cone positions as well as the load cell value respond to the dynamics of the floating bodies.</p> </li> </ul>"},{"location":"Tutorials/Simulation/SimulatorOutputLogs/","title":"Simulator Output Data Logs","text":""},{"location":"Tutorials/Simulation/SimulatorOutputPlotjuggler/","title":"View ROS 2 Messages with Plotjuggler","text":"<p>\"PlotJuggler\" is a plotting program that includes support for ROS 2 messages, and allows real-time plotting of data from ROS 2 messages while the simulator runs, as well as plotting of logged data.  </p>"},{"location":"Tutorials/Simulation/SimulatorOutputPlotjuggler/#installation-and-running","title":"Installation and Running","text":"<ul> <li> <p>To install, see instructions here.  If using the supplied docker images, this step is not necessary as the software is already installed.</p> </li> <li> <p>To start, issue the following command in a window where the environment has already been sourced using <code>$ . ~/mbari_wec_ws/install/setup.bash</code>:</p> </li> </ul> <pre><code>$ ros2 run plotjuggler plotjuggler \n</code></pre> <ul> <li>After an entertaining splash-screen, a blank PlotJuggler screen will appear. Under \"Streaming\" (upper left, second item below \"File\"), select the \"ROS 2 Topic Subscriber\" option and click \"Start\".  A new window will appear showing the ROS 2 topics available on the system.  Note that the Gazebo Simulator of the buoy must be running for the ROS 2 topics that contain the buoy data to be present.</li> </ul>"},{"location":"Tutorials/Simulation/SimulatorOutputPlotjuggler/#plotting-wave-energy-converter-data","title":"Plotting Wave Energy Converter Data","text":"<p>In the window on the left that shows the available topics, select the /arhs_data, /power_data, /spring_data, battery_data, heavecone_data and /xb_data topics and click \"OK\".  Note that for these topics to be available, the simulation needs to be running.</p> <ul> <li> <p>The selected topics will appear in the \"Timeseries List\" window, and selecting the carrot to the left of each topic will expand them and show the data that can be plotted.  Note that these topics and data are the same as are visible using the <code>$ ros2 topic list</code> and <code>$ ros2 topic echo</code> commands from the command-line.</p> </li> <li> <p>Dragging any data item into the plot field on the right will plot that data on a scrolling graph. The time-extent of the graph can be changed using the \"Buffer\" text-box under the \"Streaming\" box in the upper left.  Graphs can be split horizontally and vertically to make room for more data items, see this guide for information on manipulating the PlotJuggler windows.  </p> </li> <li> <p>After a bit of data selection, the window can look like the example below and show many data items in real-time.  Under the \"File\" box in the upper left, there are options to save and retrieve this layout to avoid setting up the windows at each invocation of PlotJuggler.  PlotJuggler will continue to run through re-starts of the simulator, so it is often not necessary to re-start PlotJuggler often.</p> </li> </ul> <p></p>"},{"location":"Tutorials/Simulation/SimulatorOutputROS/","title":"View ROS 2 Messages","text":"<p>While running, the simulator generates exactly the same ROS 2 messages that the buoy hardware does during operation.  These are grouped into ROS 2 topics that corresponds to data being produced by each micro-controller or instrument on the buoy.  To see all ROS 2 topics being published to on the system, issue the following command (after sourcing the workspace if needed in a new terminal <code>$ . ~/mbari_wec_ws/install/setup.bash</code></p> <pre><code>$ ros2 topic list \n/ahrs_data\n/clock\n/joint_states\n/parameter_events\n/power_data\n/rosout\n/spring_data\n/tf\n/tf_static\n/xb_imu\n</code></pre> <p>The topics /ahrs_data, /battery_data, /spring_data, /power_data, and /heavecone_data corresponds to the buoy-based instrumentation (AHRS), battery controller, spring controller, power-converter controller, and heave-cone controller.  Several of these topics are only available in simulation, and only /ahrs_data, /battery_data, /spring_data, /power_data, and /heavecone_data will be present on the real buoy.</p> <p>To see the data being published in these topics, issue the following command and the data will scroll by, for example:</p> <pre><code>$ ros2 topic echo power_data\n---\nheader:\n  stamp:\n    sec: 712\n    nanosec: 710000000\n  frame_id: ''\nseq_num: 6703\nrpm: 369.927978515625\nsd_rpm: 0.0\nvoltage: 313.98431396484375\ndraw_curr_limit: 0.0\nbcurrent: -0.14509780704975128\nwcurrent: -0.2554447054862976\ntorque: 0.0\ndiff_press: 2.9100000858306885\nbias_current: 0.0\nloaddc: 0.0\nscale: 1.0\nretract: 0.6000000238418579\ntarget_v: 0.0\ntarget_a: -0.2554447054862976\ncharge_curr_limit: 0.0\nstatus: 0\n---\n</code></pre> <p>The data in each topic corresponds to the message descriptions which can be seen here along with a description of each field.</p> <p>The next tutorial \"View Messages with Plotjuggler\" shows how to conveniently plot these data items while the simulator is running.</p>"},{"location":"Tutorials/Simulation/SimulatorParameters/","title":"Parameters and Batch Runs","text":""},{"location":"Tutorials/Simulation/SimulatorParameters/#introduction","title":"Introduction","text":"<p>When running a simple instance of the simulator as described in the Run the Simulator Tutorial. i.e. using:</p> <pre><code>$ ros2 launch buoy_gazebo mbari_wec.launch.py\n</code></pre> <p>the simulation uses a number of defaults for a range of parameters. In most cases, one may want to run the simulator with different values for these parameters, and/or run a number of simulations that iterate across a range of values for particular parameters. For instance, one may want to run the simulator in a batch mode that runs the same buoy and controller set-up in a range of sea-states.</p> <p>To facilitate this, a batch tool is provided that allows one to specify ranges for a number of parameters, and then run a number of simulations for all combinations of parameters, saving the results separately.</p> <p>This tutorial describes these capabilities, demonstrates with some examples, and discusses how this tool can be used.</p>"},{"location":"Tutorials/Simulation/SimulatorParameters/#parameters","title":"Parameters","text":"<p>There are a number of parameters that impact the behavior of the simulator, and must be specified at start-up:</p> <ul> <li>Simulation duration:  How long the simulation will run for (simulation time) in seconds.</li> <li>Time-step size:  The simulation proceeds at a fixed time-step size, and this can be specified for each run.</li> <li>Heave cone door-state:  Simulations can be done with the heave-cone doors either opened or closed, the door position can not be changed during a simulation, so this is a parameter that must be specified at start-up.</li> <li>Sea-State:  Incoming waves can be specified as a monochromatic wave with a specified amplitude and period, a Bretschneider spectrum of waves described by significant wave-height and the peak period, or by a custom wave-spectrum defined by a curve of wave-energy versus frequency.  </li> <li>Wave phase random seed:  The phases of each wave-component are randomly assigned, if a seed is specified, the phases will be the same for each run of a simulation.  This is useful for comparing simulations for which one wants the same wave-excitation.  If the seed value is set to zero, or omitted, a different random phase assignment will be made for each simulation run.</li> <li>Physics Real-Time Factor (RTF):  This parameter sets the maximum speed the simulation will be allowed to run, in terms of a multiple of real-time.  i.e. a Real-Time factor of 2.0 will limit the simulation to only running twice as fast as real-time.  As described below, for single runs for which one may want to monitor the motion as it occurs, a Real-Time Factor of 1.0 is appropriate.  For batches of runs one wants to complete as fast as possible, a large RTF (i.e. 100) will let the simulation run as fast as the processing resources allow.</li> <li>Battery State-of-Charge:  The starting battery state of charge can be specified between 0 (empty) and 1 (full).  A full battery can't absorb energy so more of the generated power will be diverted to the load-dump in the simulation.  An empty battery will allow most or all of the generated energy to flow to the battery. This does not effect the physical behavior of the simulated buoy, but does effect the battery voltages and currents as the simulation progresses.</li> <li>Battery EMF:  As an alternative to specifying the battery state of charge as a percentage, the zero-load battery voltage can be specified, between 270V (empty battery), and 320V (full battery).</li> <li>Scale Factor:  The buoy (and simulator) implements a default control algorithm in which the current in the motor windings is set as a function of motor RPM, with the resulting torque opposing the motors motion.  This approximately implements a linear damping behavior and the specified Scale Factor is multiplied by the default Winding-Current/RPM relationship before being applied.  Allowable values are from 0.5 to 1.4, and the result is a simple way to change the damping the power-takeoff device is applying to the system.  As discussed in a later tutorial, this relationship can be over-ridden with external code, so this Scale Factor only applies to the default behavior of the system.</li> <li>** GUI Output**:  The graphical output of the simulator can be turned on or off as needed, for large batches of runs that are meant to run un-attended this is probably not appropriate, but for single runs or debugging the graphical output can be useful.</li> </ul>"},{"location":"Tutorials/Simulation/SimulatorParameters/#example-batch-file","title":"Example Batch File","text":"<p>The above parameters are specified in a .yaml file that the batch-run tool reads in before execution begins.  A commented example is below and illustrates the use of the above parameters.  Lines that begin with # are comments and have no impact.</p> <pre><code>#\n# Batch-Specific Scalar Parameters\n#\nduration: 300\nseed: 42\nphysics_rtf: 11\n#\n# Run-Specific Parameters (Test Matrix)\n#\nphysics_step: [0.001, 0.01, 0.1]\ndoor_state: ['closed', 'open']\nscale_factor: [0.5, 0.75, 1.0, 1.3, 1.4]\nenable_gui: False\n# May specify vector/scalar battery_soc (0.0 to 1.0) or battery_emf (270V to 320V)\nbattery_soc: [0.25, 0.5, 0.75, 1.0]\n# battery_emf: [282.5, 295.0, 307.5, 320.0]\nIncidentWaveSpectrumType:\n - MonoChromatic:\n     # A &amp; T may be vector/scalar in pairs (A &amp; T same length)\n     A: [1.0, 2.0, 3.0]\n     T: [12.0, 14.0, 15.0]\n - Bretschneider:\n     # Hs &amp; Tp may be vector/scalar in pairs (Hs &amp; Tp same length)\n     Hs: 3.0\n     Tp: 14.0\n # Multiple Custom Spectra must be listed individually (f &amp; Szz are already vectors of same size)\n - Custom:\n     f: [0.0, 0.2, 0.4, 0.6, 2.0]\n     Szz: [0.0, 0.4, 1.0, 1.0, 0.0]\n</code></pre> <p>As seen in this example, some parameters are enforced to be scalar values and apply to the entire batch of specified runs.  These are the specification of simulation duration (300), random seed (42), and the physics real-time factor (11). </p> <p>The remaining run-specific parameters can be specified as arrays, and the batch-run tool then executes simulations for all possible combinations of these values.  Note that some values are specified in pairs.  For instance, three mono-chromatic waves are specified by this file with a specification of (A=1.0m, T=12s), (A=2.0m, T=14s), and (A=3.0m, T=15s), not nine runs that include all possible combinations of the specified amplitude and periods.</p> <p>Obviously it would be very easy to write a batch file specification that includes thousands of runs, more practical usage will most likely iterate over a small number of parameters at at a time. </p>"},{"location":"Tutorials/Simulation/SimulatorParameters/#running-an-example","title":"Running an example","text":"<p>For a simpler example, a batch file that iterates across a range of sea-states is used.  As a concise example, the following file illustrates this, comments have been removed for brevity.</p> <pre><code>duration: 3\nseed: 42\nphysics_rtf: 11\nenable_gui: False\nphysics_step: 0.01\ndoor_state: ['closed']\nscale_factor: [0.6, 1.0]\nbattery_soc:  0.5\nIncidentWaveSpectrumType:\n - Bretschneider:\n     Hs: [2.0, 4.0]\n     Tp: [14.0, 16.0]\n</code></pre> <p>To run this example, create the above file in a new directory and name it \"IrregularWaves.yaml\", source the simulator installation directory, and start the simulation using the batch tool. (Note that the run duration is very short for this example to allow it to complete quickly)</p> <pre><code>$ mkdir FOO\n$ cd FOO\n$ Create file using editor of your choice, name it IrregularWaves.yaml\n$ . ~/mbari_wec_ws/install/setup.bash\n$ ros2 launch buoy_gazebo mbari_wec_batch.launch.py sim_params_yaml:=IrregularWaves.yaml\n</code></pre> <p>Running these commands will run the simulation, all output is stored in a directory named similar to `batch_results_20230228210735', the trailing numbers indicate a timestamp.  Inside this directory the yaml file is repeated, along with a log file 'batch_results.log' that lists all of the simulation runs that were performed.  Alongside that are specific directories that hold output from each run.  For convenience, a symbolic link is formed that points at the most recent batch output directory.</p> <p>Within the output directory, there is a file named 'batch_runs.log' that shows each individual run that was performed, and the associated parameter.  In this case it has the following contents:</p> <pre><code># Generated 4 simulation runs\nRunIndex, SimReturnCode, StartTime, rosbag2FileName, PhysicsStep, PhysicsRTF, Seed, Duration, DoorState, ScaleFactor, BatteryState, IncWaveSpectrumType;In\ncWaveSpectrumParams\n0, 0, 20230228212457, rosbag2_batch_sim_0_20230228212457, 0.01, 11.0, 42, 3.0, closed, 0.6, 0.5, Bretschneider;Hs:2.0;Tp:14.0\n1, 0, 20230228212502, rosbag2_batch_sim_1_20230228212502, 0.01, 11.0, 42, 3.0, closed, 0.6, 0.5, Bretschneider;Hs:4.0;Tp:16.0\n2, 0, 20230228212506, rosbag2_batch_sim_2_20230228212506, 0.01, 11.0, 42, 3.0, closed, 1.0, 0.5, Bretschneider;Hs:2.0;Tp:14.0\n3, 0, 20230228212510, rosbag2_batch_sim_3_20230228212510, 0.01, 11.0, 42, 3.0, closed, 1.0, 0.5, Bretschneider;Hs:4.0;Tp:16.0\n</code></pre> <p>For simulations that take longer to run, it can be convenient to tail this log file from the terminal to keep track of progress. i.e.  From the directory the batch was started from:</p> <pre><code>$ tail -f latest_batch_results/batch_runs.log\n</code></pre>"},{"location":"Tutorials/Simulation/SimulatorParameters/#finding-the-output","title":"Finding the output","text":"<p>Within the batch process output directory, (e.g. `batch_results_20230228210735'), the output of each simulation run is stored within a single sub-directory.  The resulting directory tree from the above example is as follows:</p> <pre><code>$ tree batch_results_20230301200627/\nbatch_results_20230301200627/\n\u251c\u2500\u2500 batch_runs.log\n\u251c\u2500\u2500 IrregularWaves_20230301200627.yaml\n\u251c\u2500\u2500 results_run_0_20230301200627\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rosbag2\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 metadata.yaml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 rosbag2_0.db3\n\u251c\u2500\u2500 results_run_1_20230301200632\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rosbag2\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 metadata.yaml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 rosbag2_0.db3\n\u251c\u2500\u2500 results_run_2_20230301200636\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 rosbag2\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 metadata.yaml\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 rosbag2_0.db3\n\u2514\u2500\u2500 results_run_3_20230301200640\n    \u2514\u2500\u2500 rosbag2\n        \u251c\u2500\u2500 metadata.yaml\n        \u2514\u2500\u2500 rosbag2_0.db3\n</code></pre> <p>This output includes rosbag files and .csv files that are in the same format as the files generated on the physical buoy.  In general the information in these two files are the same, the .csv files are in clear text and are easy to inspect, and can be processed by the same tools used for the actual buoy data.  The rosbag files are binary files that encode all of the ROS2 messages on the computer during the simulation.  These files can be processed by a number of tools for post-processing and inspection of results.  It is also possible to load the rosbag files into plotjuggler for plotting and inspection, as described in the View Messages with Plotjuggler Tutorial.</p>"}]}